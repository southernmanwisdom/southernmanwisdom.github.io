<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>下一个更大元素</title>
    <url>/2024/12/03/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="下一个更大元素"><a href="#下一个更大元素" class="headerlink" title="下一个更大元素"></a>下一个更大元素</h1><p>今天解题遇到了一个类型的题目，都是使用<mark><strong>单调栈</strong></mark>来进行求解，感觉可以记录一下。</p>
<p>        <code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <strong>下一个更大元素</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入</strong>：nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].<br>输出：**[-1,3,-1]<br>解释**：nums1 中每个值的下一个更大元素如下所述：- 4 ，用加粗斜体标识，nums2 &#x3D; [1,3,<strong>4</strong>,2]。不存在下一个更大元素，所以答案是 -1 。- 1 ，用加粗斜体标识，nums2 &#x3D; [<em><strong>1</strong></em>,3,4,2]。下一个更大元素是 3 。- 2 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,<em><strong>2</strong></em>]。不存在下一个更大元素，所以答案是 -1 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入</strong>：nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].<br><strong>输出：</strong>[3,-1]<br><strong>解释</strong>：nums1 中每个值的下一个更大元素如下所述：- 2 ，用加粗斜体标识，nums2 &#x3D; [1,<em><strong>2</strong></em>,3,4]。下一个更大元素是 3 。- 4 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,<em><strong>4</strong></em>]。不存在下一个更大元素，所以答案是 -1 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></li>
<li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li>
<li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li>
</ul>
<p><strong>进阶</strong>：你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p>
<p>答：使用单调栈优先处理nums2，从后往前进行，如果栈为空说明找不到更大元素，设置为-1，并把自身压入单调栈中。如果栈不为空则比较自身与栈顶大小，栈顶小则一直pop()直到自身比栈顶小或者栈为空，如果自身比栈顶小则说明栈顶元素为更大元素。在解决的途中使用哈希表unordered_map进行存储更大元素，键：nums2的值，值：对应的更大元素的值。这样遍历nums1的同时可以根据哈希表的对应关系直接找到对应元素的更大元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hashmap;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums1.size())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums2.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> m = nums2[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()&amp;&amp;m&gt;=stk.<span class="built_in">top</span>())</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            hashmap[m]=stk.<span class="built_in">empty</span>()?<span class="number">-1</span>:stk.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">            stk.<span class="built_in">push</span>(m);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.<span class="built_in">size</span>();i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            res[i]=hashmap[nums1[i]];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="下一个更大元素Ⅱ"><a href="#下一个更大元素Ⅱ" class="headerlink" title="下一个更大元素Ⅱ"></a>下一个更大元素Ⅱ</h1><p>给定一个循环数组 <code>nums</code> （ <code>nums[nums.length - 1]</code> 的下一个元素是 <code>nums[0]</code> ），返回 <code>nums</code> 中每个元素的 <strong>下一个更大元素</strong> 。</p>
<p>数字 <code>x</code> 的 <strong>下一个更大的元素</strong> 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 <code>-1</code> 。</p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> nums &#x3D; [1,2,1]<br><strong>输出:</strong> [2,-1,2]<br><strong>解释:</strong> 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</p>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong> nums &#x3D; [1,2,3,4,3]<br><strong>输出:</strong> [2,3,4,-1,4]</p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<p>答：这道题目一样是使用单调栈进行求解，区别在于这道题目的数组设定为一个循环数组，所以一次循环并不能完美解决问题，所以需要循环两次，亦或者类同于把数组延长为2*n-1大小，把最后一位前面部分再后移也能解决问题。关键在于使用<mark>%</mark>来获取余数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()&amp;&amp;nums[i]&gt;=stk.<span class="built_in">top</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            res[i]=stk.<span class="built_in">empty</span>()?<span class="number">-1</span>:stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>栈</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>最长有效括号</title>
    <url>/2024/12/02/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h1><h3 id="给你一个只包含-39-39-和-39-39-的字符串，找出最长有效（格式正确且连续）括号子串的长度。"><a href="#给你一个只包含-39-39-和-39-39-的字符串，找出最长有效（格式正确且连续）括号子串的长度。" class="headerlink" title="给你一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长有效（格式正确且连续）括号子串的长度。"></a>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</h3><p><strong>示例 1：</strong></p>
<p><strong>输入</strong>：s &#x3D; “(()”<br><strong>输出</strong>：2<br><strong>解释</strong>：最长有效括号子串是 “()”</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入</strong>：s &#x3D; “)()())”<br><strong>输出</strong>：4<br><strong>解释</strong>：最长有效括号子串是 “()()”</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入</strong>：s &#x3D; “”<br><strong>输出</strong>：0</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 3 * 104</code></li>
<li><code>s[i]</code> 为 <code>&#39;(&#39;</code> 或 <code>&#39;)&#39;</code></li>
</ul>
<h2 id="解法一：栈的用法"><a href="#解法一：栈的用法" class="headerlink" title="解法一：栈的用法"></a>解法一：栈的用法</h2><p>        一般来说解决括号的匹配方法都是使用栈来进行匹配，所以第一时间就可以想到这种方法。栈的优势在于能够把左括号压入栈中然后遇到右括号在弹出进行匹配，完美符合括号匹配的法则。</p>
<p>        这道题的目的在于找到<strong>最长有效括号字串</strong>，先来找最长有效括号字串的<strong>特点</strong>，那就是：</p>
<p><mark>1，一定是右括号结尾。</mark></p>
<p><mark>2，一定是连续在一起结算括号</mark></p>
<p>        这其实就是有效括号的特点，所以我们一般这样解决问题：<strong>将左括号’(‘的信息压入栈中，在遍历中找到右括号’)’</strong>,纵看整个字符串，不难发现字符串总是被一些<strong>无法正常匹配的符号</strong>给截断成不同的有效字串，所以我们可以把这些<strong>无法正常匹配的符号</strong>的位置信息存放在<strong>栈中</strong>，然后正常的字串匹配完毕可以将当前的位置信息减去栈顶元素的位置，也就是截断字符串的非正常括号，这样就能一个个计算字串的长度，最终比较得出最大值。</p>
<p>        其中<strong>无法正常匹配的符号</strong>也分两种情况：</p>
<p>        1.左括号’(‘：直接正常流程压入栈中，记录位置信息。</p>
<p>        2.右括号’)’：先pop()，无法匹配说明栈中已经没有位置信息，那么也直接把’)’的位置信息压入栈中</p>
<p>有两种解题方法：</p>
<h3 id="1-直接计算长度"><a href="#1-直接计算长度" class="headerlink" title="1.直接计算长度"></a>1.直接计算长度</h3><p>先将-1压入栈中，这样即使刚开始就出现可以结算的”()”或者不可结算的单个”)”也能计算，比如说”()”，那就是先把’(‘压进栈中，然后遇到’)’后弹出，将’)’的位置信息减去栈顶元素top()，这样可以得出长度。</p>
<p><img src="file:///D:/Blog/source/_posts/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/%E6%A0%88.jpg"></p>
<p>这样依次计算找出最大值。</p>
<h3 id="2-先找出无法匹配的括号，标记出来"><a href="#2-先找出无法匹配的括号，标记出来" class="headerlink" title="2.先找出无法匹配的括号，标记出来"></a>2.先找出无法匹配的括号，标记出来</h3><p>创建情况数组bool d[],遍历一遍字符串，遇到异常情况的话把异常情况标记出来，数组标为1。</p>
<p>之后寻找数组连续0最多是多长。</p>
<h2 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h2><p>思路和算法</p>
<p>我们定义 dp[i] 表示以下标 i 字符结尾的最长有效括号的长度。我们将 dp 数组全部初始化为 0 。显然有效的子串一定以 ‘)’ 结尾，因此我们可以知道以 ‘(’ 结尾的子串对应的 dp 值必定为 0 ，我们只需要求解 ‘)’ 在 dp 数组中对应位置的值。</p>
<p>我们从前往后遍历字符串求解 dp 值，我们每两个字符检查一次：</p>
<p>s[i]&#x3D;‘)’ 且 s[i−1]&#x3D;‘(’，也就是字符串形如 “……()”，我们可以推出：</p>
<p><mark>dp[i]&#x3D;dp[i−2]+2</mark><br>我们可以进行这样的转移，是因为结束部分的 “()” 是一个有效子字符串，并且将之前有效子字符串的长度增加了 2 。</p>
<p>s[i]&#x3D;‘)’ 且 s[i−1]&#x3D;‘)’，也就是字符串形如 “……))”，我们可以推出：<br>如果 s[i−dp[i−1]−1]&#x3D;‘(’，那么</p>
<p><mark>dp[i]&#x3D;dp[i−1]+dp[i−dp[i−1]−2]+2</mark><br>我们考虑如果倒数第二个 ‘)’ 是一个有效子字符串的一部分（记作 sub‘s），对于最后一个 ‘)’ ，如果它是一个更长子字符串的一部分，那么它一定有一个对应的 ‘(’ ，且它的位置在倒数第二个 ‘)’ 所在的有效子字符串的前面（也就是 sub’s的前面）。因此，如果子字符串 sub‘s的前面恰好是 ‘(’ ，那么我们就用 2 加上 sub’s的长度（dp[i−1]）去更新 dp[i]。同时，我们也会把有效子串 “(sub‘s)” 之前的有效子串的长度也加上，也就是再加上 dp[i−dp[i−1]−2]。</p>
<p>最后的答案即为 dp 数组中的最大值。</p>
<p><img src="file:///D:/Blog/source/_posts/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png"></p>
<h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>时间空间复杂度都是O(n)</p>
]]></content>
      <tags>
        <tag>栈，动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>广东车展见闻</title>
    <url>/2024/11/27/%E5%B9%BF%E4%B8%9C%E8%BD%A6%E5%B1%95%E8%A7%81%E9%97%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
  </entry>
  <entry>
    <title>竞品分析</title>
    <url>/2024/10/21/%E7%AB%9E%E5%93%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="竞品分析"><a href="#竞品分析" class="headerlink" title="竞品分析"></a>竞品分析</h1><p>附件一：整车竞品分析基线材料</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>归属模块</th>
<th>性能大项</th>
<th></th>
<th>~</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>QC工具</title>
    <url>/2024/09/05/QC%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="QC新老七种工具"><a href="#QC新老七种工具" class="headerlink" title="QC新老七种工具"></a>QC新老七种工具</h1><h2 id="新七种"><a href="#新七种" class="headerlink" title="新七种"></a>新七种</h2><h3 id="一、关联图"><a href="#一、关联图" class="headerlink" title="一、关联图"></a>一、关联图</h3><p>就是把关系复杂而相互纠缠的问题及其因素,用箭头连接起来的一种图示分析工具，从而找出主要因素和项目的方法。</p>
<p>箭头只进不出是问题</p>
<p>只出不进是根本原因（因素）</p>
<p>有进有出是中间因素</p>
<p>出多于进是关键中间因素</p>
<h3 id="二、系统图（树图）"><a href="#二、系统图（树图）" class="headerlink" title="二、系统图（树图）"></a>二、系统图（树图）</h3><p>表示某个质量问题与其组成因素之间的关系，从而明确问题的重点，寻求达到目的所应采取的最适当的手段和措施的一种树枝状图。</p>
<p><strong>系统图优点：</strong></p>
<p>虽然在解决问题的步骤中，每个阶段都可以应用系统图，但是最重要的是在“拟定对策”的阶段中，活用系统图可以充分发掘问题的潜在原因，并且选定欲解决的目标之后，在将对策具体化的过程中，也可以运用系统图，协助我们拟定对策。</p>
<p>1&gt;图形一目了然。<br>2&gt;完整做出系统分析，避免遗珠之憾<br>3&gt;避免主观判断，容易达成共识且较具说服力。<br>4&gt;思考具逻辑性，不会偏离主题</p>
<p>注意事项：因果分析的树图一般是单目标的，一个质量问题用一个树图。</p>
<h3 id="三、亲和图"><a href="#三、亲和图" class="headerlink" title="三、亲和图"></a>三、亲和图</h3><p>a.对没有掌握好的杂乱无章的事物以求掌握；<br>b.对还没理清的杂乱思想加以综合整理归纳；<br>c.对旧观念重新整理归纳。</p>
<h3 id="四、矩阵图"><a href="#四、矩阵图" class="headerlink" title="四、矩阵图"></a>四、矩阵图</h3><p>从问题事项中，找出成对的因素群，分别排列成行和列，找出其间行与列的关系或相关程度的大小，探讨问题点的一种方法。</p>
<h3 id="五、矩阵数据分析法"><a href="#五、矩阵数据分析法" class="headerlink" title="五、矩阵数据分析法"></a>五、矩阵数据分析法</h3><h3 id="六、PDPC法（过程决策程序图法）"><a href="#六、PDPC法（过程决策程序图法）" class="headerlink" title="六、PDPC法（过程决策程序图法）"></a>六、PDPC法（过程决策程序图法）</h3><h3 id="七、箭条图"><a href="#七、箭条图" class="headerlink" title="七、箭条图"></a>七、箭条图</h3><h2 id="因果追原因、检查集数据、柏拉抓重点、直方显分布、散布看相关、管制找异常、层别作解析"><a href="#因果追原因、检查集数据、柏拉抓重点、直方显分布、散布看相关、管制找异常、层别作解析" class="headerlink" title="因果追原因、检查集数据、柏拉抓重点、直方显分布、散布看相关、管制找异常、层别作解析"></a><strong>因果追原因、检查集数据、柏拉抓重点、直方显分布、散布看相关、管制找异常、层别作解析</strong></h2><h2 id="老七种"><a href="#老七种" class="headerlink" title="老七种"></a>老七种</h2><h3 id="一、排列图"><a href="#一、排列图" class="headerlink" title="一、排列图"></a>一、排列图</h3><p>将质量改进项目从最重要到最次要的顺序排列的图表。 关键词：二八定律</p>
<p><strong>原理：关键的少数和次要的多数</strong></p>
<p>两条纵轴需要对齐，100%的时候对应的频数也得是理论的最大值</p>
<p>需要注意：</p>
<p>1、要找出重点，没有重点需要重新分</p>
<p>2、分类要具体，不能有不确定因素</p>
<p>应用场景：选择课题、现状分析</p>
<h3 id="二、因果图-鱼刺图"><a href="#二、因果图-鱼刺图" class="headerlink" title="二、因果图(鱼刺图)"></a>二、因果图(鱼刺图)</h3><p>表示质量特性波动与其潜在原因的关系 ，即表达和分析因果关系的图表</p>
<p>注意：</p>
<p>1、一个主要问题只能画一张因果图</p>
<p>2、画图需要开“头脑风暴”，集思广益，把每个人的意见都记录下来</p>
<p>3、因果关系的层次要分明，最高层次的原因应寻求到可以直接采取对策为止（分析到末端原因）</p>
<p>4、对分析出来的所有原因都要去现场观察、测量、实验等，加以确认</p>
<p>5、因果图常同排列图、对策表联合起来应用，统称为“两图一表”</p>
<p>应用场景：原因分析</p>
<h3 id="三、直方图"><a href="#三、直方图" class="headerlink" title="三、直方图"></a>三、直方图</h3><p>作用：</p>
<p>1）显示质量波动的状态</p>
<p>2）较直观地传递有关过程质量状况的信息</p>
<p>3）研究不同质量数据波动状况之后，就能知道</p>
<p>分为正常型直方图和偏向性直方图、双峰型直方图、孤岛型直方图、平顶型直方图、锯齿型直方图</p>
<p>应用场景：现状调查、实施对策、效果检查</p>
<h3 id="四、控制图（管理图）"><a href="#四、控制图（管理图）" class="headerlink" title="四、控制图（管理图）"></a>四、控制图（管理图）</h3><p>应用场景：区分异常波动和随机波动的</p>
<p>1.质量诊断方面：度量过程的稳定性，即过程是否处于统计控制状态</p>
<p>2.质量控制方面：确定什么时候需要对过程加以调整</p>
<p>3.质量改进方面：确认某过程是否得到了改进</p>
<h3 id="五、散布图"><a href="#五、散布图" class="headerlink" title="五、散布图"></a>五、散布图</h3><p>研究成对出现的两组相关数据之间相关关系的简单图示技术，在散布图中，成对的数据形成点子云，研究点子云的分布状态可以推测成对数据的相关程度</p>
<h3 id="六、调查图"><a href="#六、调查图" class="headerlink" title="六、调查图"></a>六、调查图</h3><p>用来系统分析收集资料和积累数据，确认事实并对数据进行粗略整理和分析的统计图表</p>
<p>应用场景：选择课题、现状调查、设定目标、确定主因</p>
<h3 id="七、分层图（分类法）"><a href="#七、分层图（分类法）" class="headerlink" title="七、分层图（分类法）"></a>七、分层图（分类法）</h3><p>按照一定的标志，把收集到的大量有关某一特定主题的统计数据加以归类、整理、汇总的一种方法</p>
<p>分层的目的在于把杂乱无章的数据</p>
<p>应用场景：选择课题、现状调查、实施对策</p>
<table>
<thead>
<tr>
<th align="center">老七种</th>
<th align="center">新七种</th>
</tr>
</thead>
<tbody><tr>
<td align="center">理性</td>
<td align="center">感性</td>
</tr>
<tr>
<td align="center">大量的数据资料</td>
<td align="center">大量的语言资料</td>
</tr>
<tr>
<td align="center">问题发生后的改善</td>
<td align="center">问题发生前的计划、构想</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
  </entry>
  <entry>
    <title>市场分析信源</title>
    <url>/2024/07/30/%E5%B8%82%E5%9C%BA%E5%88%86%E6%9E%90%E4%BF%A1%E6%BA%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="盖世汽车研究院"><a href="#盖世汽车研究院" class="headerlink" title="盖世汽车研究院"></a>盖世汽车研究院</h1><p><strong>拥有乘用车产销量数据库</strong> </p>
<p><u>首页即可查看当月产销量概况，包含产销量趋势、分布地图，以及动力形式占比、近12个月各车型级别份额变化图，派系、车企、车系排行榜，数据清晰直观，简单明了。</u></p>
<p><img src="file:///D:/Blog/source/_posts/%E5%B8%82%E5%9C%BA%E5%88%86%E6%9E%90%E4%BF%A1%E6%BA%90/%E7%9B%96%E4%B8%96%E6%B1%BD%E8%BD%A6.png"></p>
<p><u>产销量的预测数据可按派系、车型级别、动力形式、车企、品牌、车系等全维度检索详细数据，时间可具体到月度。</u></p>
<p><u>预测数据的月度累计和同期对比数据自动生成可视化图，免去人工作图和分析时间。其中的详细数据可一键下载表格，或截屏保存。</u></p>
<p><u>全国乘用车市场产量产能分布可自动生成概况图，直观感受产量分布趋势。盖亚（GAIA）系统覆盖整个中国市场，囊括120余家车企，2000+款车型，供君选择。用户可通过车企名称和省市进行精确搜索。</u></p>
<h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>可视化做的不错，销量和产量都可以通过清晰的柱状图和折线图清楚的看到数据，而且还可以通过分布地图看到中国各个地方的数据，并且还可以分类查看，根据车型，动力类型，车企分类。</p>
<p>另外，还可以把数据导入进去帮助你做表(可能会有泄露，保密的东西不要放进去)</p>
<p><img src="file:///D:/Blog/source/_posts/%E5%B8%82%E5%9C%BA%E5%88%86%E6%9E%90%E4%BF%A1%E6%BA%90/%E7%9B%96%E4%B8%96%E6%B1%BD%E8%BD%A6%E5%81%9A%E8%A1%A8.png"></p>
<p>但是没有国际市场的数据，看看国内的还行，但是数据的来源应该基本上都来自于盖世汽车的合作方提供，精确度不能保证。</p>
<h1 id="中国汽车工业协会"><a href="#中国汽车工业协会" class="headerlink" title="中国汽车工业协会"></a>中国汽车工业协会</h1><p>看起来像官方的网站，数据应该也挺准的，但是更新不及时，更新数据可能不是这个网站的首要任务，并且很多地区的数据比较老，基本上就是有数据更新就更新，后面就不管了。看看国内汽车总销量产量和进出口数据还可以，这种数据就会更新，其他的随缘。比如说像俄罗斯、墨西哥这些国家甚至都没有数据。</p>
<p>但是文章上好像有攥写报告记者的电话，如果有必要可以打打电话问问可不可以要一份相关数据。</p>
<h1 id="乘联会"><a href="#乘联会" class="headerlink" title="乘联会"></a>乘联会</h1><p>国内市场的数据挺详细的，数据来自于国家统计局</p>
<p><img src="file:///D:/Blog/source/_posts/%E5%B8%82%E5%9C%BA%E5%88%86%E6%9E%90%E4%BF%A1%E6%BA%90/%E4%B9%98%E8%81%94%E4%BC%9A.jpg"></p>
<p><img src="file:///D:/Blog/source/_posts/%E5%B8%82%E5%9C%BA%E5%88%86%E6%9E%90%E4%BF%A1%E6%BA%90/%E4%B9%98%E8%81%94%E4%BC%9A2.jpg"></p>
<h1 id="J-D-POWER"><a href="#J-D-POWER" class="headerlink" title="J.D.POWER"></a>J.D.POWER</h1><p>一家全球知名的市场研究公司，专注于消费者洞察、市场研究和数据分析。J.D. Power在汽车领域有着丰富的经验和数据积累，其发布的汽车销量和消费者满意度报告具有很高的权威性。但是想看报告得加入会员</p>
<h1 id="Autostat"><a href="#Autostat" class="headerlink" title="Autostat"></a>Autostat</h1><p>专门分析俄罗斯市场的俄罗斯本地平台，数据详细，不仅有俄罗斯的市场分析，还会对俄罗斯人做抽样调查之类的，但是如果需要更加详细的数据就需要订阅会员，一个月1000块？</p>
<h1 id="Saudi-Car"><a href="#Saudi-Car" class="headerlink" title="Saudi Car"></a>Saudi Car</h1><p>提供汽车资讯、市场数据和车型评测的沙特阿拉伯本地网站。</p>
<p><a href="https://saudi-car.com/car-news">沙特阿拉伯、海湾国家和世界的汽车新闻 |沙特汽车 (saudi-car.com)</a></p>
<p>新闻好像不更新了，最新的汽车新闻还是2024年3月份的</p>
<h1 id="YallaMotor"><a href="#YallaMotor" class="headerlink" title="YallaMotor"></a>YallaMotor</h1><p>中东地区大部分国家的喜好好像都有，提供中东地区汽车市场的最新信息和排名。</p>
<h1 id="Mordor-Intelligence"><a href="#Mordor-Intelligence" class="headerlink" title="Mordor   Intelligence"></a>Mordor   Intelligence</h1><p>专业做报告的</p>
<h1 id="俄罗斯信源"><a href="#俄罗斯信源" class="headerlink" title="俄罗斯信源"></a>俄罗斯信源</h1><h2 id="yandex"><a href="#yandex" class="headerlink" title="yandex"></a>yandex</h2><p>是俄罗斯的最常用的搜索引擎</p>
<h1 id="autostat"><a href="#autostat" class="headerlink" title="autostat"></a>autostat</h1><p>如上</p>
<h2 id="AEB"><a href="#AEB" class="headerlink" title="AEB"></a>AEB</h2><p>有数据</p>
<p><strong>AEB从品牌的官方代表处收集官方信息，但现在许多市场领导者，尤其是奇瑞和吉利，并不按月提供。反过来，Autostat 对所有品牌进行计数，但不是根据汽车经销商的销售事实，而是根据在交警处注册时所有权变更的事实。因此，一些已售出的汽车并没有立即包含在Autostat的统计数据中。</strong> </p>
]]></content>
  </entry>
  <entry>
    <title>学生时代的总结</title>
    <url>/2024/07/13/%E5%AD%A6%E7%94%9F%E6%97%B6%E4%BB%A3%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>随着大学时期的结束，考研的失利，我也算是结束了我的学生生涯，虽然后面还能再考研重新就读，但是从现在起已经算半只脚踏入了社会，来到陌生的城市远离家人一个人打拼，这无疑更加考验我个人的努力和天分。正好昨晚上停电，就留出了多余的时间和遐想的空间来思考我的整个的学习时代的利与弊，哪些做得好哪些又是我迟迟没有改的弊端，做这个不是为了去感叹过去为什么这样做，那是人生时日无多的老年人或者对未来绝望的人所做的事，我现在正年轻，正是充满拼劲的时候，自然是为了在人生的第二阶段——工作中让自己趋于完美，加强自己的学习，为后面回到家乡做好准备。我的任务不只是能养活自己，还要养活我的家人，家庭的负担也开始到了我的身上，这既是压力也是动力，所以我才需要更加密切的关注自身，回顾自身的经历，无论是好的还是不好的，这些都是组成我的重要的一部分，都促使着我向前或向后的发展，福兮祸所依，祸兮福所伏，好的坏的都将成为我的养分，让我做到更好。</p>
<h1 id="小学"><a href="#小学" class="headerlink" title="小学"></a>小学</h1><p>小学时的我也可谓是意气风发，虽然那时候不懂这些含义，但是却青春洋溢，愿意去展示自我。不过这也很正常，一个读书成绩优异、热爱运动、喜爱阅读、交友广泛、长得也帅气的人怎么想也不会畏畏缩缩，这就是物质条件带来的精神上面的改变，只会越来越强，而不会变弱除非条件改变。但是事物总是有着两面性，在成绩优异的背后总会有着付出。为了成绩上的优异，我周末的时候总是充满了补习班，从早上一直上到晚上，周末一直在上课，根本没有休息的时间。另外，和身边的小伙伴的不同，家里面的电脑我也很少能玩，最多在周末的时候有我爸匀出来的半个小时供我玩耍，或者取得优异成绩的时候能玩一下。当然，哪里有‘压迫’哪里就有’反抗‘，我开始学会偷奸耍滑，想方设法获得家里平板电脑的密码，这样我就能偷偷在自己的房间里面玩，又或者去补习班的时候不认真听课，和几个认识的狐朋狗友一起偷偷玩手机或者看小说。在紧张的环境下，我学会了自我放松，这也为后来的学习埋下了祸根。但总的来说，小学的学习还是功大于过，在5年级的时候通过小升初的考试和景炎初中的入学考试，也算成功，总体来说功大于过吧。</p>
<p>优点：</p>
<p>1.喜爱阅读：作为当时最常见而且父母也乐意的娱乐手段，我一直将阅读作为自己最大的爱好，在阅读的过程中积累了很多知识和辞藻，这对我的语文起到了很大的作用，而且这也帮我学会了怎么集中自己的精神专注于一件事情上面，受益良多。</p>
<p>2.敢于展现自我，喜欢与众不同：听我爸说，最开始的班主任——欧阳老师就是这么评价我的，因为我在低年级的语文作业上面抄写词汇的时候总是喜欢使用没有学习过的词语，因为这样我能认识新鲜事物，并且我在课堂上面也乐意展现自我，积极回答问题，培养了我自信的一方面吧。</p>
<p>3.经常运动，和同学与小朋友之间打成一片：在家里面经常蹲墙，锻炼了身体和意志。因为乐观开朗的性格和很多朋友和小孩都有着良好的关系。</p>
<p>4.善良，保持了一份纯真的善心，愿意保护比我小的小朋友而放弃滑板车的掌控让自己从坡上摔下来，也因此获得了友谊。</p>
<p>缺点：</p>
<p>1.喜欢偷懒：因为父母的管束比较严厉，我的学习都要靠父母的推动下才乐意去学习，我开始在一直不间歇的学习中偷懒开小差。</p>
<h1 id="初中"><a href="#初中" class="headerlink" title="初中"></a>初中</h1><h2 id="得过且过的初一"><a href="#得过且过的初一" class="headerlink" title="得过且过的初一"></a>得过且过的初一</h2><p>初中开始就放浪形骸了，这段时间单从负面意义上来讲对我的<strong>人生影响最大</strong>，首先第一次离家这么远，脱离了父母的管束，一时间放松了自己，另一方面，来到了优秀的学校认识了优秀的人，原本在小学培养的自信甚至是自傲（因为后期我开始上课看小说但是成绩还是班上名列前茅）开始消失，甚至于怀疑自己。当然，还是物质决定意识，首先我的入学考试成绩是两门70分，应该还是可以所以分进了创新班1417这个优秀的集体中，但是因为没有了父母的严厉教导，再加上小学后期的放纵自我，使我没有摆脱原来的路径依赖，开始认为自己只需要每天上好课就足以应对平时的学习。晚自习的时候也开始偷看小说，甚至不愿意去做自己的作业，基本上全靠抄，爸妈买的五年中考三年模拟也没有动过，没有足够的练习和锻炼，这样的成绩当然不会出彩，特别是在1417这个集体中，但是饶是如此，我虽然总分并不算靠前，但是还名列中游，并且我的每门科目都达到了A的水平，5A，这更让我放松了警惕，认为这样子下去也不是不行，值得一提的是，当时我的舍友是马维能和林炜琛，林炜琛学习很用功但是成绩还是不如马维能和我，被我和马维能狠狠的嘲笑了，但是从初二开始他的成绩就突飞猛进步入前三行列。这就是初一的时候，虽然学习不认真但是好歹上课还是认真听了，没有课后的积累但是单纯靠着上课的积累还处于中不溜秋的地方，这让我的心理还存着一份侥幸，让我慢慢的步入深渊。</p>
<h2 id="狂飙的初二"><a href="#狂飙的初二" class="headerlink" title="狂飙的初二"></a>狂飙的初二</h2><p>到了初二，班上住宿的人变多了，我一个人被分到了三班的宿舍，这下真是狐朋狗友了，我开始的时候成绩还行，靠着吃老本和作业的实力还能位居17名，但是由于初一一整年都没有动过五三这种练习题，所以我每次一想做题目的时候就犯困，再加上我的基础实在是太差了，有的五三上面的题目对我来说有点难，并且就算配备了详细答案的题目我照样有地方看不懂，一些关键步骤上不知道怎么展开的，并且每次问问题别人的回答我听不懂，但是为了面子还是装作懂了，慢慢的也绝了问问题的这种心态。自信心在慢慢滑落，放纵无度的心态逐渐浮现。我住的宿舍除了我以外都是1403班的同学，另外还有隔壁寝室住的1401班的同学，大家其实还是蛮友善的，毕竟少年之间的友情都是在聊天打屁中慢慢培养起来的，隔壁寝室的同学经常来我们寝室串门，甚至晚上偷偷来我们寝室一起玩然后一起睡觉，如果宿管刘四清老师在外面查寝，那么他们就从窗户那里爬过来，我后来也试过几次从窗户那边去隔壁寝室，说实话，还好初中的时候体重不大，所以没出什么差错，现在想想还是相当惊险的。虽然大家相处不到一个学期，但是这样的互动使我们的友谊逐渐升温，还记得有和我一样喜欢看书但是也喜欢故作高明的左劲松，喜欢和我一个被窝里睡身材娇小的蒋别，为人豪爽大方的何昊宇，家庭富裕喜欢二次元的吴瀚博等等，虽然很久没有联系了但现在想起来还印象深刻。</p>
<p><img src="file:///D:/Blog/source/_posts/%E5%AD%A6%E7%94%9F%E6%97%B6%E4%BB%A3%E7%9A%84%E6%80%BB%E7%BB%93/203.jpg" title alt style="zoom:80%;"> <img title src="file:///D:/Blog/source/_posts/%E5%AD%A6%E7%94%9F%E6%97%B6%E4%BB%A3%E7%9A%84%E6%80%BB%E7%BB%93/smile.jpg" alt style="zoom:33%;"></p>
<p>朋友们热情好客这是好事，但是同时和他们在同一个屋檐下日积月累还是慢慢的传染了他们的坏习惯。首先是喜欢半夜不睡觉一起玩手机，我和吴瀚博在一个被窝里面一起看动漫，我这辈子看动漫看最多的时候大概就是这个时候，每天看到凌晨3、4点，然后再7点钟顶着睡意去操场上出早操，这样怎么能上课不睡觉，所以上课也开始打起了瞌睡，反而下课居然不困，然后就是周而复始，上课睡觉下课玩耍，晚上不写作业（借李彦青的抄），然后深夜看动漫。成绩这段时间也开始一落千丈，直接掉到班上倒数第几的位置。甚至于因为他们周末会一起去玩，所以我也跟着一起去，才发现他们是去黑网吧打游戏，直到那一天的到来（巨大转折点？）。</p>
<p>那一天其实是月考的前一天，因为明天就要月考了，所以跟家里面讲周末不打算回去了，专心在学校里面准备考试。其实是准备周末陪那几个朋友一起出网吧里头打游戏去，月考什么的那时候对我来说已经不算什么了，心里面已经放弃了学习，和朋友玩的痛快这才是真的。结果那天因为太激动风风火火的所以被宿管给逮着了，提醒我说要出校门必须要请假条，但是由于我已经出去了很多次了，所以没有把这事放在心上面，因为我去教室里面学习了你宿管也不知道啊，然后就和同学拿着晚自习一些同学积累在讲台的废请假条出了门禁。在我和朋友们玩耍的正high的时候，意想不到的事情正在悄然发生。因为迟迟没有看到我回宿舍的身影，宿管居然打了班主任谢银浩的电话，然后谢老师又把这件事情告诉了我的家里，这下好了，一石激起千层浪，都以为我失踪了，发动全家人的力量去找我，然后我父亲在景炎学校的门口从中午蹲守到了傍晚，在我手拿着饮料美滋滋的准备回到学校准备晚自习的时候突然冲到我面前就是一记敲脑袋，这下是真完了，但是事情其实还有补救的余地，只要没有透露我们去网吧这种学校禁止的娱乐场所，只说我们在外面玩还不至于到如此地步，然后我就让铁哥们吴瀚博帮我去找那几个和我一起的人去传话，统一口径，结果万分叮嘱的事情被他给搞砸了，他跑到别人面前的时候居然就忘了我说的什么了（笑），然后就是口径不统一，我说的比较轻，另一个同学说的比较重，说是去了城市英雄打了下电游，然后两权相害取其重，就是家长们和老师们采取了他的说法，所以我就被狠狠的惩罚了，不仅在月考过后当着老师同学的面当众检讨（至今还记得谢老师说这是第一次也是唯一一次），而且还退出了住宿，彻底离开了那些“狐朋狗友”。爸妈在学校周边租了房，从此过上了走读的生活。纵观这一个学期，可以发现不管是做人还是学习方面都是彻头彻尾的失败，学习上失去了自律和自信，连最基本的上课和作业都做不到，丢掉了自己的基本盘，也失去了原来中部的位置，成功进入末流。做人方面只和舍友们的关系变得密切，但是却忘了要善交益友，不交损友，这些“好朋友”无法让你从他们身上学到好的品质，却传染了你坏的品质。同时因为这次的检讨事件，给班上的同学们也留下了深刻的印象，对我的评价也下滑了一个档次，并且因为住宿也远离了同班同学，所以和他们的交流十分有限，总的来说没有什么新的朋友。而舍友这些也只能算酒肉朋友，因为首先他们自己就有已经相处了一年的朋友了，我才和他们相处了不到一个学期很快就离开了，另外我们之间的关系进行也就只有从平时的玩耍培养，所以我只能算一个玩伴，比不得其他人。不过吴瀚博和我的关系还算融洽，因为我们不仅每天晚上一个被窝里看动漫，并且我退宿之后还有所联系，上一个补习班后还会去书城一起上三楼看点二次元周边什么的，但是这种关系到我上了高中也就彻底断了。</p>
<h2 id="努力又不努力的走读"><a href="#努力又不努力的走读" class="headerlink" title="努力又不努力的走读"></a>努力又不努力的走读</h2><p>后面的日子我就进入了走读时期，我们新开了两门课，物理和化学，两门课的老师也让我印象深刻，大气开朗的言珍和憨厚智慧的夏帆，这其中发生了很多的故事，在这里就不一一细谈，但是得继续说明我此刻的学习状态，初二下学期开始我就已经彻底的丢失了自信，但是走读离开了住宿环境之后还是在慢慢变好，五三等训练册也开始做了起来，虽然还是基于父母的要求，但是多少有了些主动性，但是学习的欲望始终不够强烈，虽然我的生物地理成绩在慢慢变好，但是基础的鸿沟还是难以逾越，因为我自身也只愿意完成最低限度的学习就可以了。初三的日子也大抵如此，虽然在某些领域也找回了一些自信，比如说物理的电学、语文的阅读理解等方面，甚至有一次达到了班上前十的位置，但是终归是学习欲望不强，自信心不足，总是会对自己的学习怀疑自己的理解是不是有问题，但是求助同学又听不懂，偶尔被同学奚落就受不了。所以仅仅只完成了基本的任务，然后还上一部分的补习班，补足了我的不足之处，所以我还是经常能拿到5A的水平，但是每门的分数都不高，勉强达到A的水平，基本上就是年级500名左右的水准。但是磕磕绊绊中考最后也有5A，最后进入了二中。</p>
<p>初中让我印象深刻的不好的事其实有两件事吧，第一件就是那年二中也像景炎一样搞了个预选，去考试的同学都可以有机会进入更好的班级——创新班、重点班什么的。我成绩不行所以没有这个资格，然后很多成绩中等的同学因为报了一个很高级的培训班有这个名额，当然，我也报过这种班，但是纯粹睡觉度过，没有珍惜学习的机会。最后家里面打电话过去问能不能给个名额试一试的时候，没有成功要到，然后我父亲对我说：抱歉家里面没给你这次机会，让我感受到了对自己学习不上心的悔恨。然后就是在评选德育5A的时候，班上的名额其实很多5A的份额，只有那么几个人不会是5A，并且有4个人那时候因为早恋已经确定拿不到5A了。那时候已经到了初三的末尾，我那时候成绩虽然不能说优异，但是也算是牢牢掌握着5A的名额，已经不能算弱了，而且平时的表现什么的也不再像初二那样出阁，照常理来说怎么看我都不会是那几个人之间。这次的评选是同学之间的互相评选然后班主任再微调，那天评选我也算兢兢业业，为了同学们的评价也算认真负责，改来改去就是为了让尽可能多的同学能有个好的评价。然后后来谢老师叫我去办公室告诉我班上评选的情况你是2A3B，谢老师认为这不应该是我的评价，改成了4A1B，并对我说了另一个让我印象深刻的话：到高中记得重新交点好朋友。我不怪班上的某些朋友，我只怪自己没有做的很好，班上的朋友很少有能交心的朋友，可能李彦青算一个，并且我自己在初中的表现也确实不出色，甚至是底下，但是朋友之间居然连客观的评价也没有做到，这确实使我吃了一惊，也成了横在我心中的一根刺。</p>
<p>优点：</p>
<p>1.保持了一份善心：会花很长的时间让同学们的评价都能尽可能的好。</p>
<p>2.经历了检讨事件后对不好的方面会拒绝诱惑。</p>
<p>缺点：</p>
<p>1.没有足够的自律，在缺少父母的控制下失了格，自己放弃了学习的积累。</p>
<p>2.学习的欲望不够强烈，就算是走读也每天回到家偷偷玩平板电脑，直到砸烂，经常接口学习用父母的电子手机看小说。</p>
<p>3.没有做到善交益友不交损友，并且知心的朋友很少。</p>
<p>4.自信心不足，影响了很多方面，第一，学习起来老是怀疑自己，念头不通畅，学习效率底下，学习欲望低。第二，不敢于表现自己，导致班上的同学对自己的印象仅仅限于不好的方面，好的方面没有展现出来。第三，不敢据理力争，再碰到别人质疑的时候不敢反驳，喜欢自己重新思考，但是自己明明是对的怎么还在那里思考呢？</p>
<p>5.失去了集中注意力的能力，因为班主任管的严，在初一以后，我在任何时候在班上看小说之类的书，都会被班主任直接没收，而像张留决这些同学可以看，原因就是学习成绩不好，导致从初二到初三基本上就没有认真的沉下心来阅读过一本书，进而失去了集中注意力的能力，开始喜欢在上课的时候神游天际，发呆。</p>
<p>6.学习不够连贯：没有给自己制定计划，往往都是一时兴起就去做练习册上的题目，却发现从自己开始做的一直到自己学到的部分留下了大量的空白等着自己去填补。</p>
<h1 id="高中"><a href="#高中" class="headerlink" title="高中"></a>高中</h1><h2 id="惊喜的高一"><a href="#惊喜的高一" class="headerlink" title="惊喜的高一"></a>惊喜的高一</h2><p>高中是人生的重大转折点，因为高考是人生难得的机遇，还好我把握住了它。</p>
<p>中考拿下5A后我成功进入了二中，算是比较成功吧，至少初中并没有白读。但是进入的是平行班，就是最差的一类班级，身边的初中同学大部分都因为那一次机会进入了创新班或者重点班，来到了一个完全陌生的班级，班级内仅有两三个我认识的，这对于我来说无疑是一种挑战。</p>
<p>因为初中的惨痛经历，所以我开始反思自己，并且开始认认真真地脚踏实地地完成我的学习，所以每一天的晚自习上，我除了完成作业以外，还会去完成每天学习的课程的五三上面的内容，实现了学习的积累。我应该感谢这样的举动，因为正是因为这个行为才有了后面的发展。最初，我还是认为自己的成绩会很拉跨，因为无论是校内的数学选拔比赛还是物理发下来的随堂测验我两个都完成的很差，但是即使这样还是去兢兢业业的进行学习上面的积累，不知不觉间我发生了悄然地变化，我自己也没察觉得到，直到第一次月考才发现。</p>
<p>终于，第一次月考到了，我惊讶地发现我居然位列班上第四，学习的积累最终还是开出了花。就此培养了我的自信，我开始不在对自己疑惑，开始展示自我，开始获得了一些平常学生不会有的”特权“。高中其实并没有什么值得大书特书的事件，但是确实影响我最深刻的一段时间，光荣在于平淡，艰巨在于漫长，学习的积累没有停下，而学习的成果最终反馈到了自身，然后让自己更加的自信。</p>
<p>优点：</p>
<p>1.学习的坚持，每天都坚持学完新的东西就到训练册去巩固它。</p>
<p>缺点：</p>
<p>1.阅读到很晚的时候，甚至到了印象学习的地步。</p>
<h1 id="大学"><a href="#大学" class="headerlink" title="大学"></a>大学</h1><p>优点：</p>
<p>1.交到了知心好友</p>
<p>缺点：</p>
<p>1.看小说影响休息，不够节制，一到上课就犯困</p>
<p>2.缺乏足够的信息源，找不到学习的渠道</p>
<p>3.缺乏劲头，错误的学习方法带来错误的结果，最后没有什么劲头继续学习下去</p>
<p>4.平时不出门，结友不多，朋友稀少</p>
<p>5.懒惰</p>
<p>6.贪食，体重增加到70公斤</p>
]]></content>
  </entry>
  <entry>
    <title>湘潭韶山游记</title>
    <url>/2023/08/27/%E6%B9%98%E6%BD%AD%E9%9F%B6%E5%B1%B1%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2023/08/02/%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="图的物理实现"><a href="#图的物理实现" class="headerlink" title="图的物理实现"></a>图的物理实现</h2><h3 id="邻接矩阵-相邻矩阵"><a href="#邻接矩阵-相邻矩阵" class="headerlink" title="邻接矩阵(相邻矩阵)"></a>邻接矩阵(相邻矩阵)</h3><h4 id="图的相邻矩阵表示法"><a href="#图的相邻矩阵表示法" class="headerlink" title="图的相邻矩阵表示法"></a>图的相邻矩阵表示法</h4><ul>
<li><p>图的顶点元素是|V|的顺序表</p>
</li>
<li><p>图的相邻矩阵是一个|V|×|V|矩阵</p>
</li>
<li><p>如果从Vi到Vj存在一条边，则对第i行的第j个元素做标记，否则不做标记</p>
</li>
<li><p>如果矩阵中的元素要存储边的权值，那么矩阵的每个元素必须足够大（存储权值），或者存储一个指向权值存储位置的指针。</p>
</li>
</ul>
<h4 id="具体图如下："><a href="#具体图如下：" class="headerlink" title="具体图如下："></a>具体图如下：</h4><p><img src="/2023/08/02/%E5%9B%BE/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png"></p>
<h4 id="特点分析"><a href="#特点分析" class="headerlink" title="特点分析"></a>特点分析</h4><ul>
<li><p>可以存储无向图或者有向图</p>
</li>
<li><p>相邻矩阵需要存储所有可能的边，不管这条边是否实际存在。</p>
</li>
<li><p>没有结构性开销，但是存在空间浪费</p>
</li>
<li><p>相邻矩阵的空间代价只与顶点的个数有关，为O(|V²|)，图越密集空间效率越高。</p>
</li>
<li><p>基于相邻矩阵的图算法，必须查看它的所有可能的边，导致总时间代价为O(|V²|)，所以相邻矩阵适合密集图的存储。</p>
</li>
</ul>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><h4 id="邻接表表示法"><a href="#邻接表表示法" class="headerlink" title="邻接表表示法"></a>邻接表表示法</h4><ul>
<li><p>邻接表是一个包含|V|个元素的顺序表</p>
</li>
<li><p>每个元素包含两个域，一个存储图的一个顶点信息，另一个是一个指针，指向该顶点的边构成的链表。</p>
</li>
<li><p>这个链表通过存储顶点的邻接点来表示对应的边，链表中的每个节点存储顶点的邻接点在顺序表中的位置。</p>
</li>
<li><p>如果要存储边的权值，则链表中的结点增加一个数据域(存储权值，或者存储一个指向权值存储位置的指针)</p>
</li>
</ul>
<h4 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h4><p><img src="/2023/08/02/%E5%9B%BE/%E9%82%BB%E6%8E%A5%E8%A1%A8.png"></p>
<h4 id="邻接表的特点分析"><a href="#邻接表的特点分析" class="headerlink" title="邻接表的特点分析"></a>邻接表的特点分析</h4><ul>
<li><p>可以用于存储无向图和有向图</p>
</li>
<li><p>邻接表的空间代价与图中边的数目和顶点数目都有关系。每个顶点都要一个数组元素的位置(即使该顶点没有边)，而每条边必须出现在其中某个顶点的链表中，所以邻接表的空间代价为O(|V|+|E|)</p>
</li>
<li><p>仅存储图中实际的边，没有空间浪费，但是存在结构性开销，图越稀疏，其空间效率越高</p>
</li>
<li><p>基于邻接表的图算法，需查看某个顶点和与其相邻的实际的边，其总时间代价为O(|V|+|E|)，所以邻接表适合稀疏图。</p>
</li>
</ul>
<h3 id="逆邻接矩阵"><a href="#逆邻接矩阵" class="headerlink" title="逆邻接矩阵"></a>逆邻接矩阵</h3><p>其实就是邻接表反过来，邻接表记录的是以当前顶点为弧尾的边，那么逆邻接表就是记录以当前顶点为弧头的边。方便记录入度。</p>
<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>和树的孩子兄弟表示法一样，十字链表法的每个弧结点都有两个指针域，分别指向弧头相同的下一条弧和弧尾相同的下一条弧。之所以用弧，是因为十字链表法分为两个部分：分别是顶点表和边表，顶点表里存放的是顶点结点，而边表中存放的是弧结点；它与邻接表不同之处在于<strong>它每个顶点后存的不再是顶点而是边</strong>。边里面就有两个结点。根据这两个节点方便我们统计有向图的出度和入度。</p>
<p>但是值得一提的是，十字链表法只适用于有向图：</p>
<p><img src="/2023/08/02/%E5%9B%BE/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8.png"></p>
<h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>邻接多重表用与十字链表法相同的存储结构来优化邻接表表示的无向图，无向图的空间复杂度是O(|V|+2|E|)，邻接表里面的边多出来一倍，造成了空间上的浪费，所以就有了邻接多重表。</p>
<p>如下图所示，两个指针分别指向下一条依附于前面顶点的边；因此我们有多少条边才会有多少个边结点，空间复杂度也变成了O(|V|+|E|)</p>
<p><img src="/2023/08/02/%E5%9B%BE/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8.png"></p>
<h3 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h3><h2 id="图的最小生成树"><a href="#图的最小生成树" class="headerlink" title="图的最小生成树"></a>图的最小生成树</h2><h3 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h3><p>prim算法和dijkstra算法很像，都是从一个点出发，开始找未联通但是距离最近的点，重复此操作知道形成极小连通图，更适合边稠密型的图；并且Prim算法的时间复杂为O(|E|^2)。</p>
<p><img src="/2023/08/02/%E5%9B%BE/prim.gif"></p>
<h3 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h3><p>kruskal算法则是一种边的算法，他通过找到代价最小的边开始，如果变量两边的结点都已经联通，那么就不计入，如果未联通则加入，直到生成连通图。所以kruskal更适合边稀疏图，因为使用并查集，所以时间复杂度为O(|E|log|E|)。</p>
<p><img src="/2023/08/02/%E5%9B%BE/kruskal.gif"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵</title>
    <url>/2023/07/24/%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><ol>
<li><p>数乘矩阵和矩阵的加法和数的计算差不多。</p>
</li>
<li><p>矩阵的乘法不满足交换律，顺序很重要，第一个矩阵的列数必须和第二个矩阵的行数一致。但是结合律和分配律存在，要注意矩阵的先后顺序。矩阵的乘法消去律不成立。</p>
</li>
<li><p>AB&#x3D;0不能推出A&#x3D;0或B&#x3D;0.</p>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2023/07/14/%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(<span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function">   </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(nodeArray[rt].<span class="built_in">element</span>()!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">     &#123; </span><br><span class="line">        <span class="built_in">Inorder</span>(nodeArray[rt].<span class="built_in">left</span>());</span><br><span class="line">        cout&lt;&lt;nodeArray[rt].<span class="built_in">element</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">Inorder</span>(nodeArray[rt].<span class="built_in">right</span>()); </span><br><span class="line">     &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(<span class="type">int</span> rt)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="keyword">if</span>(nodeArray[rt].<span class="built_in">element</span>()!=<span class="string">&#x27;#&#x27;</span>) </span><br><span class="line">   &#123; </span><br><span class="line">      <span class="built_in">Inorder</span>(nodeArray[rt].<span class="built_in">left</span>());</span><br><span class="line">      cout&lt;&lt;nodeArray[rt].<span class="built_in">element</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">      <span class="built_in">Inorder</span>(nodeArray[rt].<span class="built_in">right</span>()); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(<span class="type">int</span> rt)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(nodeArray[rt].<span class="built_in">element</span>()!=<span class="string">&#x27;#&#x27;</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">postorder</span>(nodeArray[rt].<span class="built_in">left</span>()); </span><br><span class="line">    <span class="built_in">postorder</span>(nodeArray[rt].<span class="built_in">right</span>()); </span><br><span class="line">    cout&lt;&lt;nodeArray[rt].<span class="built_in">element</span>()&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrderTraverse</span><span class="params">(<span class="type">int</span> rt)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">   <span class="keyword">if</span>(nodeArray[rt].<span class="built_in">element</span>()!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">          q.<span class="built_in">push</span>(rt); </span><br><span class="line">   <span class="type">int</span> temp;</span><br><span class="line">   <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) </span><br><span class="line">  &#123; </span><br><span class="line">     temp=q.<span class="built_in">front</span>();</span><br><span class="line">     cout&lt;&lt;nodeArray[temp].<span class="built_in">element</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">     q.<span class="built_in">pop</span>();</span><br><span class="line">     <span class="type">int</span> l=nodeArray[temp].<span class="built_in">left</span>();</span><br><span class="line">     <span class="type">int</span> r=nodeArray[temp].<span class="built_in">right</span>();</span><br><span class="line">     <span class="comment">//左右孩子不为空时则依次进入队列 </span></span><br><span class="line">     <span class="keyword">if</span>(nodeArray[l].<span class="built_in">element</span>()!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">     q.<span class="built_in">push</span>(l);</span><br><span class="line">     <span class="keyword">if</span>(nodeArray[r].<span class="built_in">element</span>()!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">     q.<span class="built_in">push</span>(r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>层次遍历可以用队列来实现，先将根节点放入队列中，然后弹出，同时将子节点放入队列，这样一直循环一直到队列为空为止。</p>
<p>记得当时上人工智能的时候就用到了队列，好像是A*算法吧，虽然不是树的结构，是图的结构，但也大同小异。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>栈与队列</title>
    <url>/2023/07/14/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>栈是只允许在一段进行插入和删除操作的特殊的线性表。上课时老师把栈类比为弹匣，子弹被压进弹匣，不能从另一端出来，所以后面放进来的反而能先出，正所谓”后来居上”。 </p>
<p>栈的基本操作大同小异，基本如下：</p>
<blockquote>
<p>1.初始化一个空栈</p>
<p>2.判断栈是否为空</p>
<p>3.将一个元素入栈：记得检查是否栈满,链栈不必检查</p>
<p>4.将一个元素出栈：记得检查是否栈空</p>
<p>5.返回栈顶的值</p>
<p>6.销毁栈，释放空间</p>
</blockquote>
<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><p>顺序栈顾名思义，就是用顺序结构实现的栈，其主要特点和顺序表一致，需要划一片连续的存储空间来进行存储，基本上通过数组实现。</p>
<p>栈的顺序存储类型可描述为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">int</span> data[MaxSize]; <span class="comment">// 创建栈的空间，用数组表示</span></span><br><span class="line">  <span class="type">int</span> top; <span class="comment">// 用于表示栈顶元素的在数组中的位置</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>

<p>top可以设置为-1也可以设置为0，这个每个题目不同视情况而定。</p>
<p>但顺序栈的缺点和顺序表一样，空间大小是固定死的，不能随机应变，而且还要连续的存储空间，有时候不易实现。</p>
<p>顺序栈中为了更加有效利用存储空间，提出共享栈，让两个顺序栈共享一个一维数组空间，两个栈的空间相互调节，通过两个栈顶指针相减为1判断栈满，减少存储空间，降低发生上溢的可能。</p>
<p><img src="/2023/07/14/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%85%B1%E4%BA%AB%E6%A0%88.png"></p>
<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><p>链栈也很明显，采用了链式存储结构，优点在于便于多个栈共享存储空间和提高其效率，并且不会存在栈满上溢的情况。所有的操作都是在单链表的表头进行。</p>
<p>队列的基本操作如下：</p>
<blockquote>
<p>1.初始化队列</p>
<p>2.判断队列是否为空</p>
<p>3.入队，要检查队列是否满了</p>
<p>4.出队，要检查队列是否为空</p>
<p>5.读队头元素。</p>
</blockquote>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>队列和栈一样，也是受到限制的线性表，他只能在一端输出一端输入，和我们平时的排队很像，不允许插队，也不能中途离队，只能从队尾开始排，从队头出。</p>
<h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><p>顺序队列还是一样还是顺序结构，分配一块连续的存储空间存放队列的元素，并附设两个指针：队头指针和队尾指针。</p>
<p>队列的顺序存储类型可描述为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; </span><br><span class="line">    <span class="type">int</span> data[MaxSize];<span class="comment">// 用于存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front, rear;<span class="comment">// 用于存放队头和队尾指针，分别指向队头元素在队列数组中的位置和队尾元素的下一个位置</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>

<p>队尾指针指向的位置也是可以变动的，视情况而定。</p>
<p>但是顺序队列有他的局限性，那就是判断队列是否满了不好判断，举个例子：</p>
<p>先将队列填满，那么rear队尾指针就已经到了maxsize-1，但是这时队头出去一个，那么这个队列就空出了一个，那么这个队列就没有满，但是rear的指针是不变的，所以并不能通过rear指针的位置判断队列是否满。</p>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>刚才说了顺序队列的缺陷，现在顺势引出循环队列，循环队列可以将其看作是一个环状的图形，将存储队列的元素从逻辑上看作是一个环，称为循环队列。但是当rear指针指到maxsize-1时，下一个就要到位置为0的地方，所以得到的结果应该通过取余数的方式实现         **%**。</p>
<p>那么循环队列判断队空和队满的条件是什么？显然队空的条件是Q.front&#x3D;&#x3D;Q.rear。若入队元素的速度快于出队元素的速度，那队尾指针很快就会赶上队首指针，到时候队满的条件也成了 Q.front&#x3D;&#x3D;Q.rear。以下有三种方法解决：</p>
<p><mark>1.空出一个单元不存储数据，这样的话入队就少了一个队列单元，这种做法比较普遍。那么队头指针在队尾指针的下一个位置是队满的标志。</mark> </p>
<blockquote>
<p>队满条件：(Q.rear+1)%MaxSize&#x3D;&#x3D;Q.front.</p>
<p>队空条件：Q.front&#x3D;&#x3D;Q.rear.</p>
<p>队列中元素的个数：(Q.rear-Q.front+MaxSize)%MaxSize.</p>
</blockquote>
<p><mark>2.类型增设表示元素个数的数据成员size。</mark> </p>
<blockquote>
<p>队满条件：Q.size&#x3D;MaxSize。</p>
<p>队空条件：Q.Size&#x3D;0.</p>
</blockquote>
<p><mark>3.类型中设置tag数据成员，以区分队空还是队满。tag&#x3D;0时，就表示上一个操作为删除，如果Q.front&#x3D;&#x3D;Q.rear，那就是队空；tag&#x3D;1时，表示上一个操作为插入，如果Q.front&#x3D;&#x3D;Q.rear，就表示队满。</mark></p>
<h2 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h2><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><hr>
<p>队列的链式表示被称为链队列，它是一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点，及单链表最后一个结点。<u>但是要注意头指针和头结点是不一样的，一个指向的是逻辑结构上的队头，一个指向链表的表头。</u>以下是队列的链式存储类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义链式队列的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"><span class="comment">// 定义链式队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    LinkNode *front, *rear;<span class="comment">// 链式队列中包含指向队头和队尾的指针，由于队列是队头进队尾出，因此需要标记队尾指针</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">// 用于记录队列的长度</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>&amp;ensp;&amp;ensp;  值得注意的是，不带头结点的链式队列在操作上往往比较麻烦，因此通常将链式队列设计成一个带头结点的单链表，这样操作和删除操作就统一了。</p>
<p>&amp;emsp; &amp;emsp; 用单链表表示的链式队列特别适合数据元素变动比较大的情形，而且不存在队列满且溢出的问题。另外，如果程序中要使用多个队列，与多个栈的情形一样，最好使用链式队列，这样不会出现存储分配不合理和“溢出”的问题。所以之前提到的循环队列用在链式队列中纯属画蛇添足。</p>
</blockquote>
<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><h2 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h2><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><hr>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>1. </p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>实习游记</title>
    <url>/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><p>21点出发长沙火车站，我几乎没有坐过绿皮火车，唯有的记忆就是初一的时候从厦门往来坐了次卧铺，感觉空间还行，和朋友们打牌看书就欢快的度过了一天一夜。并没有感受到采访时经常提到的人们乘坐绿皮火车回家的辛苦。</p>
<blockquote>
<p>那次的厦门之行其实没有太多值得回忆的地方，可能是因为那时候还很小，又或者景观虽然美丽但是却没有太多的感触，可能身边的朋友比美景更重要。记忆比较深刻的大概是和mhy和zjy跑到厦门大学的书店买了纪念品和几本书——《洗脑》《反洗脑》《死神永生》，前面两本书后来被我捐到初中的图书馆里面了。</p>
</blockquote>
<p>从地铁站出来，引入眼帘的就是宏伟壮观的长沙火车站，火车站就伫立在一大块平地上，附近伴生的建筑也为数众多，火车站这三个大字就位于建筑的顶上，火红的标字提醒着附近的人们这里是哪里。来往的人们也络绎不绝，大多数都是来往的旅客，其中还夹杂着几个为生活谋生的人，他们挥舞着手中的商品来进行推销，却总是遭到人们的拒绝。走进候车站，人山人海，大家都席地而坐等待候车，更有甚者甚至连地铺都打好了。</p>
<p>等啊等终于车到了，我们提着行李箱一路奔驰到车门处，学校给我们订的票是硬座，一走进去就惊到了，中间的道路十分的狭窄，能通过行李箱就已经是极限了，然后座位也是非常的狭窄，我的那个位置要坐下3个人，但是只有最里面才有小桌子，也没有充电的地方，由于我没有充电宝所以只能节省用电，掏出了我新买的《地铁》小说开始看，其实车里面的灯也是属于不是很亮的类型，散发出淡淡的黄光，就像我现在住的酒店的灯光，不是很适合读书。看了一会就感觉到了疲倦，于是闭目养神。没有桌子的依靠不方便睡眠，所以只能小憩一会就醒来继续看书。就这样半睡半醒的度过了那一段时间，终于天亮了，天亮得很早，5点出头就已经白昼，路上的美景也有不少，印象最深刻的就是广阔的农田，因为地势的平坦所以很多土地连在一起做的农田，青青的麦子在风中摇曳，给人一种”勃勃生机，万物竟发”的景象(笑)，还有就是火车在行进路上时不时就发出鸣笛的声音，悠长而尖锐，然后就看到身着工作服的火车工人们在旁边默默的等待火车的通过，感谢他们，到了白天找刘杰接了充电宝，然后开始看起了大决战系列的电影解说，时间就这样悄然过去，直到到达目的地。</p>
<p>到了杭州，还没出去，只是中途在大巴上看到的景象，感觉杭州和长沙并无太大区别，都是耸立的建筑群，然后是熙熙往来的人们。也好似我在写这篇游记时的酒店周旁，正响着耳熟能详的广场舞音乐，让我感觉好像回到了小学，我坐在自己的书房看书的时候就是广场舞音乐伴随着我。看起来所有城市都一样，有着共通性。但是我认为每个城市都有着属于自己的精神底色，这是时代、历史、文化所赋予给人们的。而要看到这一点，那就等自由时间出去游玩再去探索吧。</p>
<p>今天就到这里，因为火车上实在是疲惫，睡午觉的时候一不小心睡过了头，甚至还影响了晚上的身体，所以今天自由活动就没有出去</p>
<p><img src="/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/%E7%81%AB%E8%BD%A61.jpg"></p>
<p><img src="/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/%E7%81%AB%E8%BD%A62.jpg"></p>
<p><img src="/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/%E7%81%AB%E8%BD%A63.jpg"></p>
<h1 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h1><p>大清早一起来就发现已经7点半了，赶紧准备好行李就下楼吃早饭，发现睡觉还是睡得太晚了，7点多起来居然还是带着一丝困意，早餐还算丰盛，有手抓饭、包子馒头、烧麦、豆浆等等，匆匆吃了点就下楼准备上车。</p>
<p>上车后观察沿途的风景，我发现杭州的绿化做的很好，到处都处在绿荫之下，每隔3步就是一棵树，放眼望去一片绿意，让人心旷神怡。而且也能明显的看出杭州对这次延迟的亚运会的重视，到处都贴满了相关的标语和吉祥物–三个类似于当年奥运会的福娃一样的小人，甚至连杭州本地的企业也是相当的配合政府的宣传工作，在给我们的ppt上都有着亚运相关的标识。</p>
<p>上午我们去的是海康威视，不查不知道，海康威视居然是全球安防市场的龙头企业，是我孤陋寡闻了(😀)，先是去的3期区，去看了相关的展会，走进去体验了很多很有意思的科技，只是可惜因为保密的缘故没有拍照。</p>
<p><img src="/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/%E6%B5%B7%E5%BA%B72.jpg"></p>
<p>看得出，很多相关技术都是与感知有关的技术，其中最主要的还是基于视觉的感知吧，后来跟我们分享的主管人也是这么说的，一开始就是靠着监控发的家。应该是后面再一步步拓展扩大了业务范围，有了新的理念–安防。这种东西可以和政府形成密切的商业关系，后面也证实了我的看法，与政府的合作业务占比五分之一。只能说怪不得学校开设了计算机视觉和人工智能这两门课，足以证明这可能是未来的主流方向，不过被封锁的道路会走的相当的艰难。</p>
<p>然后就到了四期区的会议厅听报告，几位给我们宣讲的学长很有意思，两位都很腼腆，其中一位学长说的话也很有道理，就是如果你真的下定决心去做一件事，那么一年的时间足以，这次实习游玩结束之后我也当定下自己的考研决心，收心学习了。海康威视的人才培养方案看起来也相当的可以，不管是从技术层面还是管理层面都很不错，而且正常的福利薪资都很不错。</p>
<p><img src="/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/%E6%B5%B7%E5%BA%B71.jpg"></p>
<p><img src="/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/%E6%B5%B7%E5%BA%B73.jpg"></p>
<p>听完会议厅就上4楼去食堂就餐，食堂的饭菜很多种多样，我点了粉蒸肉、口水鸡、蒸蛋、瓦罐煨汤，结果也没花很多钱，感觉比学校强(乐)，不过仔细品尝还是和外面的饭店不能比，尝起来味道还不够到位。</p>
<p><img src="/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/%E9%A5%AE%E9%A3%9F1.jpg"></p>
<p>吃完饭就打道回府了，但是来杭州不去西湖就等于白来，于是在我们的强烈要求下，田泽安老师主动帮我们询问最后把我们丢到地铁站的门口，西湖之旅就这样拉开帷幕。杭州的地铁站的空间感觉比长沙要大，但是人并不算很多，而且检查也比较的放松，只扫描一下包就放行了。车费也比长沙要贵，做一段路程就有将近10元的车费，不过我们也坐了很长的一段距离就对了,杭州应该比长沙还要大很多。</p>
<p>从断桥残雪开始一直走到雷峰塔，从中午一直走到了晚上，感觉西湖并没有想象中的那样充满人文关怀和历史味，更多的反而是自然风光，西湖边上最多的是游客而不是本地人，或者说本地的文化没有体现得出来，感觉还是得去集市或者书店这样的地方可能在人与人之间的交流上才会体现出来吧。最后走的腿都软了，西湖感觉作为一个本地锻炼休息的公园比较的合适，至于其他的就感觉商业气息比较浓重了。</p>
<p><img src="/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/%E8%A5%BF%E6%B9%961.jpg"></p>
<p><img src="/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/%E8%A5%BF%E6%B9%962.jpg"></p>
<p><img src="/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/%E8%A5%BF%E6%B9%963.jpg"></p>
<p>希望后面能够有机会去一趟书店，听说这里的书店很富有古代的气息，而且有很多古籍。并且还想要一个自己的私有的印章。</p>
<h1 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h1><p>上午阴雨连绵，然后坐车坐了很久，长途非常犯困，就在路上一路睡了过去，不过在睡前也看了看杭州的风景，在途经山体的时候注意到了山上面虽然郁郁葱葱，但是山体的侧面露出的岩石光秃秃的，到处都是被腐蚀的痕迹，有的山体甚至还铺上了一层网络，没有什么植物生长在上面而且还是垂直的，感觉山体滑坡的风险还是不小的。</p>
<p>最后到了今天要参观的企业，不过感觉不如昨天的海康，官腔味比较的浓，科研的顶尖成果没怎么看到，感觉传统工业要大于高新科技，不过看得到党建做的还是可以，应该是属于中流砥柱类型的工业集团吧，与人们的日常生活密切相关。</p>
<p><img src="/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/%E5%85%9A%E5%BB%BA.jpg"></p>
<p>然后吃过盒饭就继续坐车回去了，但是由于下雨的缘故(下午没下雨了，我不知道&#x2F;(ㄒoㄒ)&#x2F;~~)，所以在房间里玩了一天的游戏。</p>
<h1 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h1><p>今天是在杭州的最后一天，也是最有意义的一天。</p>
<p>上午很早就起来，把东西都收拾好确认没有遗漏后就离开了酒店，上午还是有一点小雨的，今天来到了与第二天的人工智能小镇在一块地的之江实验室。这下可真的是国家级别的实验室了，产出的成果非常丰富，而且有很多的专利和论文都在世界的前列，可惜和海康一样禁止拍照，值得一提的是原来之江实验室和湖大有合作，看来湖大在编译领域还是颇有建树的，后面还搞了个签约仪式，可惜学生去不了。然后报告也是面向博士后的报告，基本上都是成果和成员方面的，为科研配套的建筑都在建筑之中，相当的可以。可惜的就是不管饭，这一点差评(😀)！</p>
<p><img src="/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/%E9%A5%AE%E9%A3%9F2.jpg"></p>
<p>下午放完行李就是自由活动时间，因为第三天没出去，所以最后一段时间肯定要好好利用，根据旅游手册上面的描写，河坊街有很多的纪念品和当地特产可以购买，所以我坐这地铁坐到江城路再转到吴山广场来到了河坊街，果然时古色古香的建筑。</p>
<p><img src="/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/%E6%B2%B3%E5%9D%8A%E8%A1%971.jpg"></p>
<p>先来到了一条古玩街，这一条街上都是在售卖小手工艺品，店面很小，仅仅只能坐进一个人，掀开帷幕进去，就可以感到丝丝凉意，然人惬意。但是这条街开的店面不多，只有一半不到的店面开着，我在其中寻找印章店，还真给我找到了，但是老板居然不在，仅留下商品在这里，等待片刻，原来老板就在街边上乘凉。只见老板在左下角打开一个小木板，露出一个小洞，然后老板就自己费劲的钻了进去，很是辛苦。然后就跟老板谈好了价钱，搞定了印章。接着买了点龙井给家里人之后，我直奔中山中路，想一观书房的模样。</p>
<p>穿过了一段古建筑群后来到了书房面前，书房不大，但是边上并无建筑，反而很空旷，书房用围栏给围起来，不同于其他的建筑，书房看起来是木头搭起来的，看起来更具韵味。走进书房，就看到很多小玩意摆在边上，很多是古代南宋时期的一些作品的介绍，还有一些瓷器和木器的小玩意，别具匠心，穿过了一段狭窄的道路，终于来到了空旷的房间，说是空旷，但是平地上并不空旷，摆满了各种纪念品的小玩意供来往的人们观赏和购买。真正空旷的地方反而是阶梯，阶梯很长，并且在阶梯两边设立了坐枕，大家都坐在两边，有的人戴上耳机，然后津津有味的阅读手上的书籍；有的人把鞋一脱，然后把手和脚搭在冰凉的木头上，享受着这炎热的夏日难得的凉爽，还有小孩躺在木板上，将头放在母亲的腿上，深深的睡了过去，神情喜悦。但是这里环境主要还是安静，不管什么样的人，来到这处地方都会安静下来，不想惊扰什么似的。来都来了，总得挑一本书去吧，然后我就看了看相关的书籍，书架很高，基本上只有前三层可以看到，再往上就是人们够不到也看不到的地方了，但是上面也摆放满了书籍，让人禁不住好奇上面难道是什么禁书吗。再来看书的种类，种类还是比较的丰富，很多都是历史、文化、艺术方面的书，但是都并不有名，大多小众，而且一个种类也就三排，图书量也不大。并且并不像旅游指南上面所的那样大多为南宋时期的作品或是描述南宋文化的作品。最后我挑来选去，选择了孟德斯鸠的《论法的精神》，久仰大名，希望能好好阅读。之后就打道回府了。</p>
<p><img src="/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/%E4%B9%A6%E6%88%BF1.jpg"></p>
<p><img src="/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/%E4%B9%A6%E6%88%BF2.jpg"></p>
<p><img src="/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/%E4%B9%A6%E6%88%BF3.jpg"></p>
<p>感觉南宋书房不愧书房之名吧，感觉比起单纯的卖书，反而更注重一种氛围，希望人们能够在这样的安静环境下仔细阅读，卖的什么书反而不是很重要，就像是主题店一样。</p>
<p>然后就踏上了回家的步伐，杭州之旅就这样结束了。</p>
<p>最后我们还是硬座回去，但是与之前不同，这次显得更加的拥挤，站票的人们挤作一团，蜷缩在狭窄的过道上，大部分人都在没有空调的出口那里挤着，十分的困难，更重要的是我们定的晚上的票，所以他们不得不考虑站着睡觉。有的人甚至还看上了我露出来的一点点座位的缝隙，将屁股移到那里只为了让自己能轻松一点。最后实在不好意思就席地而坐然后双手抱着膝盖这样睡觉，还要被时不时路过上厕所的人叫醒。甚至还有人2点多了还要跑到出口那里去抽烟，我也是醉了(😶)。在门口的那个胖哥们甚至站着都睡着了，还发出了很大的鼾声，姿势也很搞笑，一只手竖着搭载门沿上，身体靠在这只手的位置，另一只手垂直于门沿，手掌搭在另一个门沿上，形成了一个“直角”的姿势，不过也很辛酸的，看起来实在是太辛苦了，而且这样也没有办法睡太死，稍有动静就醒来了，那个兄弟就只能费劲的张开半只眼来观察周围的动静，然后又很快的睡着很快的醒来，周而复始。我这次还是没有分到有桌子的那一侧，所以我只好坐正了睡觉，但是每睡不了半小时就被脖子的酸痛所“叫醒”，实在没办法睡了，根本睡不着，但是又很困，睡不着就玩玩手机，然后不知不觉进入睡眠等待下一次的醒来。于是在这种半梦半醒的状态下迎来了天亮，“<strong>相与枕藉乎舟中，不知东方之既白</strong>”。</p>
<p><img src="/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/%E5%BD%92%E9%80%941.jpg"></p>
<p><img src="/2023/07/03/%E5%AE%9E%E4%B9%A0%E6%B8%B8%E8%AE%B0/%E5%BD%92%E9%80%942.jpg"></p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>最近的一些烦恼或者想法</title>
    <url>/2023/07/01/%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E7%83%A6%E6%81%BC%E6%88%96%E8%80%85%E6%83%B3%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近看了很多的关于解放战争的视频，深感现在中国的不易。但是又同时看到了地方债的问题，产业转型升级的困难和许多地方政府出现的问题，比如青海湖要围起来。每当看到底下的评论区阴阳怪气时总是颇感难受，但是基于实事求是的原则来说，这些中很多都是事实，不能因为别人的过度放大而忽视。我们是“幸运”的一代，生长于经济增长的大环境中，但是在即将登上历史舞台的时候遇到了疫情，从而经济下行，就业困难。有时候总在想，一代人有一代人的使命，或许我们这一代人的使命就是带领中国走出现在的困境迈出下一步，但是又深感无力，因为自己的力量微薄并且不算努力，能力有限，就只能干着急。</p>
<p>我和我爸其实也讨论过现在的困难处境，但是我爸也告诉我说这些事情有必要了解，因为大环境的改变会影响所有人，但是又不可过度关注，因为自己改变不了这个世界，我只能先改变自己，先把自己的事情做好，再来改变世界。过去人们的艰苦奋斗造就了现在中国人的辉煌，我就不信现在还能比过去更加的困难吗。雄关漫道真如铁，而今迈步从头越。在前人的基础上迈出属于自己的一步吧。</p>
]]></content>
  </entry>
  <entry>
    <title>数组和链表</title>
    <url>/2023/06/14/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="基础知识-数组与链表"><a href="#基础知识-数组与链表" class="headerlink" title="基础知识-数组与链表"></a>基础知识-数组与链表</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>数组</strong>是被操作系统分配的一个内存块，用来保存数组的元素。通过使用特定元素的索引作为数组下标，可以在常数时间内访问数组元素。</p>
<h3 id="数组的优点"><a href="#数组的优点" class="headerlink" title="数组的优点"></a>数组的优点</h3><blockquote>
<p>简单且易用</p>
<p>访问元素快(常数时间)</p>
</blockquote>
<h3 id="数组的缺点"><a href="#数组的缺点" class="headerlink" title="数组的缺点"></a>数组的缺点</h3><blockquote>
<p>大小固定：数组的大小是静态的（要在使用前指定数组的大小）</p>
<p>分配一个块：数组初始化分配空间时，有时不可能分配能存储整个数组的内存（如果数组的大小太大）</p>
<p>基于位置的插入操作实现复杂</p>
</blockquote>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是一种用于存储数据集合的数据结构。链表中相邻连续元素之间通过指针链接，最后一个元素的后继指针的值为NULL。</p>
<h3 id="链表的优点"><a href="#链表的优点" class="headerlink" title="链表的优点"></a>链表的优点</h3><blockquote>
<p>链表可以在常数时间拓展</p>
<p>在程序执行过程中，链表的大小可以增长或减小</p>
<p>链表的空间能够按需分配</p>
<p>没有内存空间的浪费</p>
</blockquote>
<h3 id="链表的缺点"><a href="#链表的缺点" class="headerlink" title="链表的缺点"></a>链表的缺点</h3><blockquote>
<p>链表的主要缺点在于访问单个元素的时间开销问题</p>
<p>存储空间的离散性降低了元素的存储效率</p>
<p>链表中的指针需要额外的内存开销</p>
</blockquote>
<h2 id="物理实现"><a href="#物理实现" class="headerlink" title="物理实现"></a>物理实现</h2><p><img src="/2023/06/14/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/%E6%95%B0%E7%BB%84.png"></p>
<p><img src="/2023/06/14/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8.png"></p>
<h2 id="补充-7-1"><a href="#补充-7-1" class="headerlink" title="补充-7.1"></a>补充-7.1</h2><p>顺序表的实现就是用数组完成的，优势就在于访问数据的时候直接根据下标就可以快速寻找，而链表不行，只能回归表头再顺序执行，消耗的时间比较长。但是再增删数据的情况下，数组就明显不如链表，数组必须移动增删的数据后面的数据，而链表只需要把数据域后面的指针改一下指向的方向就可以了。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>6月份学习计划</title>
    <url>/2023/06/13/6%E6%9C%88%E4%BB%BD%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>现在是6月13日，已经距离期末考试的结束有过一段时间了，而且休息也休息过了，接下来就是彻底投入到考研的准备。因为避免期末不挂科，所以用了半个多月的时间一直在复习，已经很久没有碰过考研的学习了，数学和英语都有点忘却。因为首先17日要考六级，所以这几天还是以英语的复习为主，过几天再重新开始数学的复习，而且这次考试又把我分到财院校区去了，这下又得提前踩好点。另外就是18日要开始小学期了，这次小学期我选择的是数据库相关的知识，可以提前学习。</p>
<p>6月还剩下半个月，我得把数学第二轮尽快搞完，因为还有线代没学，并且政治8、9月份的时候要开始了，后面就不会分到数学太多的时间，所以得尽快完成数学的深入学习。</p>
<p>另外就是英语，很久没有搞了，得重新将英语的学习回归日常，另外现在可以多做一些原题了，计划是每周做2篇阅读题。</p>
<p>数据结构的学习还是想放到下一个月，7月份已经放暑假了，希望能够留校，这样就可以在图书馆里学习，家里确实不适合学习，也没有免费的空调蹭。</p>
]]></content>
      <categories>
        <category>-reading</category>
      </categories>
  </entry>
  <entry>
    <title>基本流水线</title>
    <url>/2023/06/06/%E5%9F%BA%E6%9C%AC%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="基本流水线"><a href="#基本流水线" class="headerlink" title="基本流水线"></a>基本流水线</h2><h3 id="流水线的基本概念"><a href="#流水线的基本概念" class="headerlink" title="流水线的基本概念"></a>流水线的基本概念</h3><h4 id="一个任务可以分解成为k个子任务"><a href="#一个任务可以分解成为k个子任务" class="headerlink" title="一个任务可以分解成为k个子任务"></a>一个任务可以分解成为k个子任务</h4><ul>
<li><p>k个子任务在k个不同阶段(使用不同的资源)运行</p>
</li>
<li><p>每个子任务执行需要1个单位时间</p>
</li>
<li><p>整个任务的执行时间为k倍单位时间</p>
</li>
</ul>
<h4 id="流水线执行模式是重叠执行模式"><a href="#流水线执行模式是重叠执行模式" class="headerlink" title="流水线执行模式是重叠执行模式"></a>流水线执行模式是重叠执行模式</h4><ul>
<li><p>k个流水段，并行执行k个不同任务</p>
</li>
<li><p>每个单位时间，一个任务进入&#x2F;离开流水线</p>
</li>
</ul>
<p><img src="/2023/06/06/%E5%9F%BA%E6%9C%AC%E6%B5%81%E6%B0%B4%E7%BA%BF/%E6%B5%81%E6%B0%B4%E7%BA%BF.png"></p>
<h3 id="同步流水线"><a href="#同步流水线" class="headerlink" title="同步流水线"></a>同步流水线</h3><ul>
<li><p><strong>流水段之间采用时钟控制的寄存器文件</strong></p>
</li>
<li><p><strong>时钟上升沿到达时…</strong></p>
</li>
</ul>
<p>-所有寄存器同时保存前一流水段的结果</p>
<ul>
<li><p><strong>流水段是组合逻辑电路</strong></p>
</li>
<li><p><strong>流水线设计中希望各段相对平衡</strong></p>
</li>
</ul>
<p><img src="/2023/06/06/%E5%9F%BA%E6%9C%AC%E6%B5%81%E6%B0%B4%E7%BA%BF/%E6%B5%81%E6%B0%B4%E6%AE%B5.png"></p>
<h3 id="流水线的性能"><a href="#流水线的性能" class="headerlink" title="流水线的性能"></a>流水线的性能</h3><p>• 设 τi&#x3D;time delay in stage Si</p>
<p>• 时钟周期 τ &#x3D;max(τi) 为最长的流水段延迟</p>
<p>• 时钟频率 f &#x3D; 1&#x2F;τ &#x3D; 1&#x2F;max(τi)</p>
<p>• 流水线可以在k+n-1个时钟周期内完成n个任务</p>
<p>  – 完成第一个任务需要 k个时钟周期</p>
<p>  – 其他n-1个任务，在后续的n-1个时钟周期完成</p>
<p>• K-段流水线的理想加速比（相对于串行执行）</p>
<p><img src="/2023/06/06/%E5%9F%BA%E6%9C%AC%E6%B5%81%E6%B0%B4%E7%BA%BF/k%E6%AE%B5%E6%B5%81%E6%B0%B4%E7%BA%BF.png"></p>
<h3 id="典型的RISC-5段指令流水"><a href="#典型的RISC-5段指令流水" class="headerlink" title="典型的RISC 5段指令流水"></a>典型的RISC 5段指令流水</h3><ul>
<li><p><strong>五个流水段，每段的延迟为1个cycle</strong></p>
</li>
<li><p><strong>IF：取指阶段</strong></p>
<p>-选择地址：下一条指令地址、转移地址</p>
</li>
<li><p><strong>ID：译码阶段</strong></p>
<p>-确定控制信号并从寄存器文件中读取寄存器值</p>
</li>
<li><p><strong>EX：执行</strong></p>
<p>-Load&#x2F;Store:计算有效地址</p>
<p>-Branch：计算转移地址并确定转移方向</p>
</li>
<li><p><strong>MEM：存储器访问(仅Load和Store)</strong></p>
</li>
<li><p><strong>WB：结果写回</strong></p>
</li>
</ul>
<p><img src="/2023/06/06/%E5%9F%BA%E6%9C%AC%E6%B5%81%E6%B0%B4%E7%BA%BF/RISC5.png"></p>
<h3 id="流水线的可视化表示"><a href="#流水线的可视化表示" class="headerlink" title="流水线的可视化表示"></a>流水线的可视化表示</h3><h4 id="多条指令执行多个时钟周期"><a href="#多条指令执行多个时钟周期" class="headerlink" title="多条指令执行多个时钟周期"></a>多条指令执行多个时钟周期</h4><ul>
<li><p>指令按程序从上到下排序</p>
</li>
<li><p>图中展示了每一时钟周期资源的使用情况</p>
</li>
<li><p>不同指令相邻阶段之间没有干扰</p>
</li>
</ul>
<p><img src="/2023/06/06/%E5%9F%BA%E6%9C%AC%E6%B5%81%E6%B0%B4%E7%BA%BF/%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8F%AF%E8%A7%86%E5%8C%96.png"></p>
<h3 id="指令流时序"><a href="#指令流时序" class="headerlink" title="指令流时序"></a>指令流时序</h3><h4 id="时序图展示："><a href="#时序图展示：" class="headerlink" title="时序图展示："></a>时序图展示：</h4><ul>
<li>每个时钟周期指令所使用的流水段情况</li>
</ul>
<h4 id="指令流在采用5段流水线执行模式的执行情况"><a href="#指令流在采用5段流水线执行模式的执行情况" class="headerlink" title="指令流在采用5段流水线执行模式的执行情况"></a>指令流在采用5段流水线执行模式的执行情况</h4><p><img src="/2023/06/06/%E5%9F%BA%E6%9C%AC%E6%B5%81%E6%B0%B4%E7%BA%BF/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%97%B6%E5%BA%8F.png"></p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>流水线</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习</title>
    <url>/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="学习概述"><a href="#学习概述" class="headerlink" title="学习概述"></a>学习概述</h1><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>机器可以自动”学习”的算法，即从<strong>数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。</strong></p>
<h2 id="学习的反馈类型"><a href="#学习的反馈类型" class="headerlink" title="学习的反馈类型"></a>学习的反馈类型</h2><h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>不提供任何的显示反馈，比如：KNN聚类算法</p>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0.png"></p>
<h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p>提供“输入-输出”对，学习从输入到输出的映射函数。比如：贝叶斯网络，人工神经网络，决策树</p>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0.png"></p>
<h3 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h3><p>提供少量的“输入-输出”对，大部分样本未标注。基于图的学习算法。</p>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0.png"></p>
<h2 id="监督学习-1"><a href="#监督学习-1" class="headerlink" title="监督学习"></a>监督学习</h2><h3 id="监督学习的任务是："><a href="#监督学习的任务是：" class="headerlink" title="监督学习的任务是："></a>监督学习的任务是：</h3><p>1.给定由N个“输入-输出”对样例组成的训练集从给定的训练数据集中学习出一个函数（模型参数）</p>
<p>2.当新的数据到来时，可以根据这个函数预测结果</p>
<h3 id="分类与回归"><a href="#分类与回归" class="headerlink" title="分类与回归"></a>分类与回归</h3><p>分类问题的主要目的是预测分类标签，标签来自预定义的可选列表。分类问题可分为二分类和多分类。</p>
<p>比如邮件系统，对于垃圾邮件的识别就是一个分类问题。</p>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%88%86%E7%B1%BB.png"></p>
<p>回归任务的目标是预测一个连续值。</p>
<p>例如，根据教育水平、年龄和居住地来预测一个人的年收入，预测的结果是一个金额数值。</p>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E5%BD%92.png"></p>
<h2 id="K-折交叉验证"><a href="#K-折交叉验证" class="headerlink" title="K-折交叉验证"></a>K-折交叉验证</h2><p>思想：每个样本既作为训练数据，又作为测试数据</p>
<blockquote>
<p>将数据分成k个相等的子集</p>
<p>执行k轮次学习，每一轮1&#x2F;k个数据作为测试数据，其他作为训练数据</p>
</blockquote>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/K.png"></p>
<p>精度增加伴随着代价增加</p>
<h2 id="过拟合-x2F-欠拟合"><a href="#过拟合-x2F-欠拟合" class="headerlink" title="过拟合&#x2F;欠拟合"></a>过拟合&#x2F;欠拟合</h2><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><p>拟合模型时，过分关注训练集的细节，训练集学习得到的目标函数在训练集上性能很好，在测试集上性能不高。</p>
<p>训练出的模型太复杂，不能泛化到新数据上的模型就叫做过拟合。</p>
<p>其实就是训练次数过多导致找到了太多只适用于训练集的特征，过于细化所以不能通用。</p>
<h3 id="欠拟合"><a href="#欠拟合" class="headerlink" title="欠拟合"></a>欠拟合</h3><p>相反，如果模型过于简单，那么就可能无法抓住数据的全部内容以及数据中的变化。甚至可能模型在训练集上的表现也很差。也就是没要找到特征。</p>
<h3 id="如何避免过拟合"><a href="#如何避免过拟合" class="headerlink" title="如何避免过拟合"></a>如何避免过拟合</h3><ol>
<li>Early stopping （适当的stoppingcriterion）:</li>
</ol>
<p>   Early stopping便是一种迭代次数截断的方法来防止过拟</p>
<p>   合的方法，即在模型对训练数据集迭代收敛之前停止迭代</p>
<p>   来防止过拟合</p>
<p>   2) 数据集扩增 : 数据机扩增即需要得到更多的符合要求</p>
<p>   的数据，即和已有的数据是独立同分布的，或者近似独立</p>
<p>   同分布的。一般方法有：从数据源头采集更多数据，复制</p>
<p>   原有数据并加上随机噪声，重采样，根据当前数据集估计</p>
<p>   数据分布参数，使用该分布产生更多数据等</p>
<p>   3）正则化方法：一般有L1正则与L2正则等</p>
<p>   4）Dropout：正则是通过在代价函数后面加上正则项来防</p>
<p>   止模型过拟合的。而在神经网络中，有一种方法是通过修</p>
<p>   改神经网络本身结构来实现的，其名为Dropout。</p>
<h2 id="信息理论：熵"><a href="#信息理论：熵" class="headerlink" title="信息理论：熵"></a>信息理论：熵</h2><p>熵H(x)：衡量数据集的纯度</p>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%86%B5.png"></p>
<p>熵曲线</p>
<p>两个样本(P,N),p个正样本数，n个负样本数，p&#x3D;9,n&#x3D;5</p>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%86%B5%E6%9B%B2%E7%BA%BF.png"></p>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%86%B5%E6%A0%B7%E4%BE%8B.png"></p>
<h2 id="信息理论：属性选择"><a href="#信息理论：属性选择" class="headerlink" title="信息理论：属性选择"></a>信息理论：属性选择</h2><p>根据熵的定义，公平掷硬币的熵：</p>
<p>$$<br>H(Fair)&#x3D;− (0.5log_2⁡0.5 +0.5  log_2⁡0.5 )&#x3D; 1<br>$$</p>
<p>如果加载硬币，使之能掷出99%正面向上，则有</p>
<p>$$<br>H(Loaded)&#x3D;− (0.99log_2⁡0.99+0. 01log_2⁡0.01) ≈0.08<br>$$</p>
<p>设布尔变量以q的概率为真，则可定义该变量的熵为：</p>
<p>$$<br>B(q)&#x3D;− (q log_2⁡q +(1-q)log_2⁡(1-q) )<br>$$</p>
<p>因此</p>
<p>$$<br>H(Loaded)&#x3D;B(0.99)≈0.08<br>$$</p>
<p>一个训练数据集包含p个正样本,n个负样本，则目标属性在整个样例集上的熵为：</p>
<p>$$<br>H(Goal)&#x3D; B(𝑝&#x2F;(𝑝+𝑛))<br>$$</p>
<p>一个属性A的取值为A1,A2,…,Av,根据属性A的取值将训练数据集E分成E1,E2,…Ev,每个子集Ei有pi个正例和ni个反例，则选择属性A后，剩余的期望熵值为：</p>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%9B%E7%86%B5%E5%80%BC.png"></p>
<p>属性A的信息收益是<strong>熵的期望减少</strong>，即原有的熵值-属性A分裂后的熵值：</p>
<p>$$<br>Gain(A)&#x3D; B(𝑝&#x2F;(𝑝+𝑛)) - H(A)<br>$$</p>
<p>$$<br>Gain(Patrons)&#x3D; 1−[2&#x2F;12B(0&#x2F;2)+4&#x2F;12B(4&#x2F;4)+6&#x2F;12B(2&#x2F;6)]≈0.541</p>
<p>$$</p>
<p>$$<br>Gain(Type)&#x3D; 1−[2&#x2F;12B(1&#x2F;2)+2&#x2F;12B(1&#x2F;2)+4&#x2F;12B(2&#x2F;4)+4&#x2F;12B(2&#x2F;4)]&#x3D;0<br>$$</p>
<p>$$<br>Gain(Patrons)&gt;Gain(Type)<br>$$</p>
<p><strong>选择信息收益最大的属性进行分裂</strong></p>
<h2 id="决策树剪枝"><a href="#决策树剪枝" class="headerlink" title="决策树剪枝"></a>决策树剪枝</h2><p>找到<strong>过度拟合</strong>的结点，删除该节点及其分支</p>
<p>如果一个节点是过度拟合的，则该结点不同属性之下所含正样本的比例与整个集合的比例大致相同，<strong>pk&#x2F;(pk+nk)≈p&#x2F;(p+n)</strong></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
  </entry>
  <entry>
    <title>朴素贝叶斯分类算法</title>
    <url>/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>贝叶斯分类是一类分类算法的总称，算法以贝叶斯定理为基础，所以称为贝叶斯分类。本文将首先介绍分类问题，对分类问题进行一个正式的定义。然后，介绍贝叶斯分类算法的基础——贝叶斯定理。最后，通过实例讨论贝叶斯分类中最简单的一种：朴素贝叶斯分类。</p>
<h1 id="二、分类问题介绍"><a href="#二、分类问题介绍" class="headerlink" title="二、分类问题介绍"></a>二、分类问题介绍</h1><p>分类，顾名思义，就是把集合分出类别来，比如人类可以分为黄种人、白种人、黑种人。</p>
<p>在数学方面可以做如下定义：</p>
<p>已知集合：</p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E9%9B%86%E5%90%881.png"></p>
<p>和<img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E9%9B%86%E5%90%882.png"></p>
<p>确定映射规则<img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E6%98%A0%E5%B0%84%E8%A7%84%E5%88%99.png"></p>
<p>使得任意有<img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/1.png"></p>
<p>且仅有一个</p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/2.png"></p>
<p>使得<img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/3.png"></p>
<p>成立<br>        其中C叫做类别集合，其中每一个元素是一个类别，而I叫做项集合，其中每一个元素是一个待分类项，f叫做分类器。分类算法的任务就是构造分类器f。<br>        值得注意的是，分类问题常常采用经验性方法构造映射规则，及一般情况下的分类问题缺少足够的信息来构造百分百正确的映射规则，而是通过对经验数据的学习从而实现一定概率意义上的正确的分类，因此从训练出的分类器并不是一定能准确地将每个待分类项映射到其分类，分类器的质量与分类器构造方法、待分类数据的特性以及数据样本数量等诸多因素相关。</p>
<h1 id="朴素贝叶斯算法前提说明"><a href="#朴素贝叶斯算法前提说明" class="headerlink" title="朴素贝叶斯算法前提说明"></a>朴素贝叶斯算法前提说明</h1><p>朴素贝叶斯算法成立的前提：<strong>各属性之间相互独立</strong>。当数据集满足这种独立性假设时，分类的准确度较高，否则可能较低。</p>
<h1 id="贝叶斯定理理论基础"><a href="#贝叶斯定理理论基础" class="headerlink" title="贝叶斯定理理论基础"></a>贝叶斯定理理论基础</h1><p>贝叶斯定理是关于随机事件（或边缘概率）的一则定理。这个定理解决了现实生活里经常遇到的问题：已知某条件概率，如何得到两个事件交换后的概率，也就是在已知P(A|B)的情况下如何求得P(B|A)</p>
<p>贝叶斯定理之所以有用，是因为我们在生活中经常遇到这种情况：我们可以很容易直接得出P(A|B)，P(B|A)则很难直接得出，但我们更关心P(B|A)，贝叶斯定理就为我们打通从P(A|B)获得P(B|A)的道路。</p>
<p>下面不加证明地直接给出贝叶斯定理：</p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E8%B4%9D%E5%8F%B6%E6%96%AF.png"></p>
<h1 id="朴素贝叶斯分类的原理和流程"><a href="#朴素贝叶斯分类的原理和流程" class="headerlink" title="朴素贝叶斯分类的原理和流程"></a>朴素贝叶斯分类的原理和流程</h1><h2 id="思想基础"><a href="#思想基础" class="headerlink" title="思想基础"></a>思想基础</h2><p>朴素贝叶斯的思想基础：对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，就认为此待分类项属于哪个类别。就比如说你在大街上见到一个黑哥们，你肯定首先认为他是个非洲人，但实际上黑人非洲、亚洲、美洲都有。但是非洲的黑人最多概率最大，所以你会认为他是个非洲人。</p>
<h2 id="图示流程"><a href="#图示流程" class="headerlink" title="图示流程"></a>图示流程</h2><p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E6%B5%81%E7%A8%8B.png"></p>
<h2 id="正式定义"><a href="#正式定义" class="headerlink" title="正式定义"></a>正式定义</h2><p>1.设   <img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E5%BE%85%E5%88%86%E7%B1%BB%E9%A1%B9.png">为一个待分类项，而每个a为x的一个特征属性</p>
<p>2.有类别集合<img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E9%9B%86%E5%90%881.png"></p>
<p>3.计算</p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%971.png"></p>
<p>4.如果<img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%972.png"></p>
<p>那么x∈yk</p>
<p>现在的关键就是如何计算第三步的各个条件概率。可以这样做：</p>
<p>1、找到一个已知分类的待分类项集合，这个集合叫做训练样本集。</p>
<p>2、统计得到在各类别下各个特征属性的条件概率估计。即：</p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%973.png"></p>
<p>3、如果各个特征属性是条件独立的，则根据贝叶斯定理有如下推导：<img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E6%8E%A8%E5%AF%BC.png"></p>
<p>因为分母对所有的类别为常数，因此我们将分子最大化即可。又因为各特征属性是条件独立的，所以有：</p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E7%BB%93%E8%AE%BA.png"></p>
<p> 可以看到，整个朴素贝叶斯分类分为三个阶段：</p>
<p>      第一阶段——准备工作阶段，这个阶段的任务是为朴素贝叶斯分类做必要的准备，主要工作是根据具体情况确定特征属性，并对每个特征属性进行适当划分，然后由人工对一部分待分类项进行分类，形成训练样本集合。这一阶段的输入是所有待分类数据，输出是特征属性和训练样本。这一阶段是整个朴素贝叶斯分类中唯一需要人工完成的阶段，其质量对整个过程将有重要影响，分类器的质量很大程度上由特征属性、特征属性划分及训练样本质量决定。</p>
<p>      第二阶段——分类器训练阶段，这个阶段的任务就是生成分类器，主要工作是计算每个类别在训练样本中的出现频率及每个特征属性划分对每个类别的条件概率估计，并将结果记录。其输入是特征属性和训练样本，输出是分类器。这一阶段是机械性阶段，根据前面讨论的公式可以由程序自动计算完成。</p>
<p>      第三阶段——应用阶段。这个阶段的任务是使用分类器对待分类项进行分类，其输入是分类器和待分类项，输出是待分类项与类别的映射关系。这一阶段也是机械性阶段，由程序完成。</p>
<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>这一节讨论P(a|y)的估计。</p>
<p>      由上文看出，计算各个划分的条件概率P(a|y)是朴素贝叶斯分类的关键性步骤，当特征属性为离散值时，只要很方便的统计训练样本中各个划分在每个类别中出现的频率即可用来估计P(a|y)，下面重点讨论特征属性是连续值的情况。</p>
<p>      当特征属性为连续值时，通常假定其值服从高斯分布（也称正态分布）。即：</p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83.png"></p>
<p>因此只要计算出训练样本中各个类别中此特征项划分的各均值和标准差，代入上述公式即可得到需要的估计值。均值与标准差的计算在此不再赘述。</p>
<p>      另一个需要讨论的问题就是当P(a|y)&#x3D;0怎么办，当某个类别下某个特征项划分没有出现时，就是产生这种现象，这会令分类器质量大大降低。为了解决这个问题，我们引入Laplace校准，它的思想非常简单，就是对没类别下所有划分的计数加1，这样如果训练样本集数量充分大时，并不会对结果产生影响，并且解决了上述频率为0的尴尬局面。</p>
<h3 id="实验：汽车估计数据集"><a href="#实验：汽车估计数据集" class="headerlink" title="实验：汽车估计数据集"></a>实验：汽车估计数据集</h3><p>一．数据描述：</p>
<p>n汽车评估数据集包含1728个数据，其中训练数据1350，测试数据 378个。每个数据包含6个属性，所有的数据分为4类：</p>
<p>ClassValues: unacc, acc,good, vgood</p>
<p>Attributes:</p>
<p>buying: vhigh,high, med, low.</p>
<p>maint: vhigh,high, med, low.</p>
<p>doors:2, 3, 4, 5more.</p>
<p>persons:2, 4, more.</p>
<p>lug_boot:small, med, big.</p>
<p>safety:low, med, high.</p>
<p>未校准：</p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E6%9C%AA%E6%A0%A1%E5%87%861.png"></p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E6%9C%AA%E6%A0%A1%E5%87%862.png"></p>
<p>校准后：</p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E6%A0%A1%E5%87%861.png"></p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E6%A0%A1%E5%87%862.png"></p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E4%BE%8B%E9%A2%98.png"></p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E7%AD%94.jpg"></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>贝叶斯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>监听法和目录法</title>
    <url>/2023/05/27/%E7%9B%91%E5%90%AC%E6%B3%95%E5%92%8C%E7%9B%AE%E5%BD%95%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
  </entry>
  <entry>
    <title>计算机体系结构-Tomasulo算法</title>
    <url>/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Tomasulo%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-与记分牌算法的比较"><a href="#1-与记分牌算法的比较" class="headerlink" title="1.与记分牌算法的比较"></a>1.与记分牌算法的比较</h2><h3 id="1-1-重新审视数据冒险"><a href="#1-1-重新审视数据冒险" class="headerlink" title="1.1    重新审视数据冒险"></a>1.1    重新审视数据冒险</h3><p><strong>假数据冒险影响了记分牌算法的乱序性能</strong>。</p>
<p>那么什么是假数据冒险呢？</p>
<p>我们都知道，数据冒险有WAW,WAR,RAR,RAW这四种，而其中RAR其实在流水线中并没有影响指令的执行，所以可以把它忽略。</p>
<p>在剩下三个之中，只有RAW“写后读”才是真冒险，而WAR和WAW都是假冒险。为什么呢？因为这两种冒险都是在第一个操作后进行写操作，说明写操作的目标寄存器是被使用的状态，所以必须阻塞自己才能不引发冲突。而解决方法其实很简单，只要把写操作的目标寄存器改变成没有冲突的寄存器就可以解决。</p>
<p>但是<strong>RAW是无解的</strong>，因为后续指令读取的数据必须由前序指令算的，有明显的数据依赖，所以才是”真冒险”</p>
<p><strong>这三种冒险的差别就出现在”数据依赖方面”<strong>。读后写”和“写后写”通过改写寄存器名字就可以消除冒险，这表明这两种冒险其实没有数据依赖，</strong>即发生冒险的指令之间其实没有数据流动</strong>。想要挖掘出指令的乱序潜力，理解这一点非常重要。</p>
<p><strong>综上所述，“写后写”和“读后写”冒险不是真冒险，没必要为他们阻塞指令的流动</strong></p>
<p>例子：</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Tomasulo%E7%AE%97%E6%B3%95/%E7%A4%BA%E4%BE%8B1.jpg"></p>
<p>首先看“写后写”WAW冒险，可以看到第一条、第三条指令都要写R3寄存器，犯了“写后写”冒险。在记分牌中如果遇到这种情况，后序的AND指令因为和ADD指令发生“写后写”冒险，所以无法发射，流水线在发射阶段堵塞。</p>
<p><strong>但是如果把AND指令的目的寄存器改写成R10，那么冒险就消除了</strong>，AND指令可以发射，只不过写回的目的寄存器是R10而不是R3。</p>
<p>同样的，审视“读后写”WAR冒险。第一条指令和第二条指令关于R3发生了“读后写”冒险，在记分牌中如果碰到这种情况，第二条指令在写回阶段时会检测到第一条指令需要读取R3旧值，所以第二条指令会卡在写回阶段，直到第一条指令读取完R3并且通知到自己为止。</p>
<p><strong>如果把第二条指令的R3改写成R10，冒险就又解决了</strong>，第一条指令可以去读R3，第二条指令的更新结果存在R10，不会覆盖R3的旧值。</p>
<h3 id="1-2-Tomasulo算法与记分牌"><a href="#1-2-Tomasulo算法与记分牌" class="headerlink" title="1.2     Tomasulo算法与记分牌"></a>1.2     Tomasulo算法与记分牌</h3><p>记分牌存在巨大的缺点，每个运算部件只有一个译码信息流水段寄存器，这意味着多配置处理器中的每一条配置通路同一时间只能存在一条指令，如果某一配置通路被占据，那么后面所有的指令都要被阻塞。</p>
<p><strong>而且记分牌为了乱序执行指令，在碰到写后写、读后写这两个冒险的时候也会暂停流水线（为什么这里不提写后读呢，见后文），而这其实是不必要的，因此记分牌算法还是没有最大限度地挖掘出指令的乱序潜力</strong>。而且记分牌的“写回”是乱序的，乱序完成指令不利于处理器处理中断、异常等情况，不利于程序员debug程序。</p>
<p>Tomasulo采用了许多记分牌中的理念</p>
<p>两个较大的差异</p>
<blockquote>
<p><strong>Tomasulo算法中，冲突检测和执行控制是分布的，利用保留站实现</strong></p>
<p><strong>Tomasulo算法不用检查WAR和WAW相关，已经使用算法本身消除掉了</strong></p>
</blockquote>
<h3 id="寄存器重命名"><a href="#寄存器重命名" class="headerlink" title="寄存器重命名"></a>寄存器重命名</h3><p><strong>消除假数据相关的主要方法是寄存器重命名</strong>。</p>
<p>寄存器重命名其实就是修改寄存器的名字，防止寄存器冲突。那么就意味着需要在原来寄存器的基础上额外有寄存器。</p>
<p>实现额外寄存器的方法有两种</p>
<p>可以在逻辑寄存器（MIPS指令集规定了32个逻辑寄存器）之外额外有一组物理寄存器，结构如图。假如逻辑寄存器正要被改写或被读，就置Busy位为1，并通过Tag指示最新数据将被写到哪一个物理寄存器。通过这样的方法，我们可以在新数据计算完毕时立刻写回，同时也允许前序指令读取寄存器旧值（因为旧值没有被覆盖，它还存在于逻辑寄存器中）。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Tomasulo%E7%AE%97%E6%B3%95/%E7%A4%BA%E4%BE%8B2.jpg"></p>
<p>上面这种方法把逻辑寄存器和物理寄存器分离开，其实完全可以把两者混合起来，即为处理器提供超过逻辑寄存器数量的寄存器，如MIPS指令集要求32个逻辑寄存器，那就设计40个物理寄存器给处理器，至于哪些寄存器是ISA要求的32个寄存器，则视程序运行情况而定，相关信息可以用一个表格存储起来，理论上任何一个物理寄存器都可能是任何一个逻辑寄存器。</p>
<p>上面简单说明了两种寄存器重命名的方法，Tomasulo算法采用了第一种，但是不彻底，<strong>说Tomasulo算法蕴含寄存器重命名的思想则更合适。</strong></p>
<h2 id="2-Tomasulo算法"><a href="#2-Tomasulo算法" class="headerlink" title="2. Tomasulo算法"></a>2. Tomasulo算法</h2><h3 id="2-1-Tomasulo算法产生的背景"><a href="#2-1-Tomasulo算法产生的背景" class="headerlink" title="2.1 Tomasulo算法产生的背景"></a>2.1 Tomasulo算法产生的背景</h3><h4 id="IBM-360-x2F-91比CDC6600-记分牌算法-晚三年推出"><a href="#IBM-360-x2F-91比CDC6600-记分牌算法-晚三年推出" class="headerlink" title="IBM 360&#x2F;91比CDC6600(记分牌算法)晚三年推出"></a>IBM 360&#x2F;91比CDC6600(记分牌算法)晚三年推出</h4><p>商业计算机使用cache技术之前</p>
<h4 id="整个360系列仅一个指令系统和一个编译器"><a href="#整个360系列仅一个指令系统和一个编译器" class="headerlink" title="整个360系列仅一个指令系统和一个编译器"></a>整个360系列仅一个指令系统和一个编译器</h4><p>要求具有很高的浮点性能，但不是通过高端机器的专用的编译器实现</p>
<p>只有四个双精度浮点寄存器，编译器调度的有效性受到很大限制</p>
<p>访存时间和浮点计算时间都很长</p>
<p>可支持循环的多次迭代重叠执行</p>
<h3 id="2-2-Tomasulo算法的结构"><a href="#2-2-Tomasulo算法的结构" class="headerlink" title="2.2    Tomasulo算法的结构"></a>2.2    Tomasulo算法的结构</h3><p><strong>Tomasulo最大的特点就是通过借助重命名的思想消除了假数据冒险，从而提高了机器的乱序性能</strong>。</p>
<p>先看这个结构：</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Tomasulo%E7%AE%97%E6%B3%95/%E7%A4%BA%E4%BE%8B3.jpg"></p>
<ul>
<li>首先是FP OP Queue，这里是浮点指令队列，指令在这里等待发射；</li>
<li>青绿色模块是加法单元和乘法单元的保留站（保留站是什么？保留站保留已经发射的指令的信息和缓冲下来的数据。关于保留站，后文会有更多介绍）；</li>
<li>蓝绿色的Address Unit是地址计算单元，在这个算法中存储指令在执行前会先计算好存储地址；</li>
<li>Memory Unit则是存储单元；</li>
<li>CDB是数据广播总线，它可以直达寄存器堆（用来更新通用寄存器）、加法乘法存储单元的保留站（输送保留站中指令需要的数据）。</li>
</ul>
<p>要解读Tomasulo算法，<strong>就要搞清楚这个算法运用了哪些信息来调度指令，然后要分清楚算法的调度步骤</strong>。接下来首先解释Tomasulo算法利用了哪些信息，然后讲解算法的调度步骤。</p>
<h4 id="2-2-1-保留站和寄存器结果状态表"><a href="#2-2-1-保留站和寄存器结果状态表" class="headerlink" title="2.2.1  保留站和寄存器结果状态表"></a>2.2.1  保留站和寄存器结果状态表</h4><p>保留站是Tomasulo算法的精髓，不同于记分牌每一个配置通路前面的译码信息流水段寄存器，记分牌中每一条配置通路只能存放一条指令，<strong>而Tomasulo算法则为每一条通路配置了一组缓冲</strong>。就像上图中的绿色模块，其中浮点加法单元拥有能够缓冲三条指令的保留站。保留站存储的信息和记分牌有点类似。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Tomasulo%E7%AE%97%E6%B3%95/%E7%A4%BA%E4%BE%8B4.jpg"></p>
<p>保留站的结构有点像cache，可能有多行数据，每一行都对应一条被发射到保留站的指令。保留站每一行都有Busy位，指示这一行是否现存有指令；Vj和Vk与记分牌不同，记分牌的Vj和Vk会记录源寄存器的编号，<strong>而保留站则直接把能读取的数据直接拷贝到保留站中</strong>，可想而知，一旦数据进入保留站，那对应的寄存器就和这条指令没瓜葛了；Qj和Qk的信息和记分牌一样，记录尚不能读取的数据将由哪条指令算出；A是存储指令的地址，用于存放立即数和计算得到的地址数据。</p>
<p>看上去保留站和记分牌非常相似，但是两者其实有很大的不同。以上图的Add为例，保留站中有三行Add信息，这三行数据对应的是同一个加法单元，而在记分牌中这代表着三个加法单元。记分牌那样的一条通路只对应一条信息的做法容易造成指令堵塞、无法发射，<strong>而保留站则为每条通路预留了缓冲区，指令可以在加法单元忙碌的时候发射到保留站的缓冲区待命</strong>。</p>
<p>其次，保留站会直接把读取的数据缓冲下来，而不像记分牌一样只记录一个寄存器编号，只记录编号的话会造成读后写阻塞，因为一条指令在正式执行前一直在监控着它的源寄存器，源寄存器的值是不能改变的，因此后续指令无法写回，只能阻塞流水，<strong>而保留站则贯彻了“数据一旦准备完毕，就立马执行指令”的思想</strong>，指令一旦发现有数据可读，就立马读下来，读下来之后，那个源寄存器的写与不写就不关己事了。</p>
<p>记分牌和保留站相同的地方是都记录了Qj和Qk，即一旦需要的数据被算出来，就通过Qj和Qk捕捉广播数据，<strong>这样的做法其实就是重命名，即用保留站的编号而不是寄存器编号来标记数据源</strong>。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Tomasulo%E7%AE%97%E6%B3%95/%E7%A4%BA%E4%BE%8B6.jpg"></p>
<p>除了保留站数据结构之外，Tomasulo同样要记录寄存器结果状态，记录信息如图6.和记分牌一样，Tomasulo也会记录寄存器将被哪条指令更新，这个信息在指令寻找源数据时被使用。</p>
<h4 id="2-2-2-调度流程"><a href="#2-2-2-调度流程" class="headerlink" title="2.2.2  调度流程"></a>2.2.2  调度流程</h4><h5 id="MIPS五阶段的流水线的改造"><a href="#MIPS五阶段的流水线的改造" class="headerlink" title="MIPS五阶段的流水线的改造"></a>MIPS五阶段的流水线的改造</h5><p>ID和EX阶段被以下三个阶段代替</p>
<p>1.流出(Issue)</p>
<p>2.执行(Execute)</p>
<p>3.结果写回(Write result)</p>
<h5 id="流出-Issue"><a href="#流出-Issue" class="headerlink" title="流出(Issue)"></a>流出(Issue)</h5><p>1.从浮点指令队列中取出一条指令</p>
<p>2.如果存在一个空的保留站，就流出这条指令</p>
<p>3.如果操作数在寄存器中，就送到该指令对应的保留站</p>
<p>4.存储器取&#x2F;存指令只要有空闲的缓存就可以流出</p>
<p>5.如果没有空闲的保留站或者缓存，就存在结构相关，指令暂停，直到有空闲的保留站或者缓存</p>
<h5 id="执行-Execute"><a href="#执行-Execute" class="headerlink" title="执行(Execute)"></a>执行(Execute)</h5><p>1.如果缺少一个或者多个操作数，就监听CBD</p>
<blockquote>
<p>这个阶段实际是检测和自动维护RAW相关</p>
</blockquote>
<p>2.如果两个操作数都就绪，这条指令就可以执行</p>
<h5 id="结果写回-Write-result"><a href="#结果写回-Write-result" class="headerlink" title="结果写回(Write result)"></a>结果写回(Write result)</h5><p>1.如果结果已经产生，将其写到CBD上</p>
<p>2.通过CDB,把这个结果写到目标寄存器和等待这个结果的所有功能单元的保留站</p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>指令的动态调度</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机体系结构-记分牌ScoreBoard</title>
    <url>/2023/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%AE%B0%E5%88%86%E7%89%8CScoreBoard/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-什么是记分牌"><a href="#1-什么是记分牌" class="headerlink" title="1.什么是记分牌"></a>1.什么是记分牌</h2><p>首先需要认识到一个事实：<strong>顺序执行的处理器有瑕疵</strong></p>
<p>比如说lw指令后面跟着一连串与它无关的指令，但是lw指令发生了 data cache miss 的情况，导致了必须访问主存，所以就很慢，但是它卡在访存阶段几十上百个周期，如果是顺序执行，后面的指令会等他结束在执行，效率太低，<strong>如果想要实现“继续执行”，即后面的指令“绕过” lw 指令继续执行，那么就需要处理器支持乱序</strong></p>
<h3 id="1-1-乱序执行"><a href="#1-1-乱序执行" class="headerlink" title="1.1 乱序执行"></a>1.1 乱序执行</h3><p>顺序执行的效率太慢，如果有一条指令阻塞，那么后面所有的指令都会阻塞，所以设计师开了几条近道，让后面的指令可以绕过前面的指令，从而继续执行。</p>
<p>在乱序情况下，<strong>只要一条指令所需要的数据准备好了，那么就执行这条指令</strong>，而不用像顺序执行一样既要准备好数据，又要前面的指令把”路“让出来。</p>
<h3 id="1-2-多配置流水"><a href="#1-2-多配置流水" class="headerlink" title="1.2 多配置流水"></a>1.2 多配置流水</h3><p>传统的五级流水线中，所有的指令都要走完运算通路，计算指令不需要访问存储器，所以完全可以绕开存储器，但正是因为这样的规定，导致前面的lw指令卡在了访存环节中，导致计算指令只能等lw指令把存储器让出来。</p>
<p>所以就有了<strong>多配置流水</strong>，针对不同的计算指令的不同的要求，为之开辟不同的道路，有这些路指令就可以实现超车。<strong>多配置流水的处理器可以实现乱序执行。</strong></p>
<h3 id="1-3-记分牌算法"><a href="#1-3-记分牌算法" class="headerlink" title="1.3 记分牌算法"></a>1.3 记分牌算法</h3><p>下面是CDC 6600 的结构示意：</p>
<p><img src="/2023/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%AE%B0%E5%88%86%E7%89%8CScoreBoard/CDC6600%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F.jpg"></p>
<p>可以看到有两个浮点乘法器(FP mult)，一个浮点除法器(FP divide)，一个浮点加法器(FP add)，一个整型单元(Integer unit:用于计算存储地址)，和记分牌(Scoreboard),记分牌是信息存储单元，接下来两张图解释它究竟什么功能。</p>
<p><img src="/2023/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%AE%B0%E5%88%86%E7%89%8CScoreBoard/%E8%AE%B0%E5%88%86%E7%89%8C%E5%AD%98%E5%82%A8%E7%9A%84%E4%BF%A1%E6%81%AF-%E5%8A%9F%E8%83%BD%E5%8D%95%E5%85%83%E7%8A%B6%E6%80%81.jpg"></p>
<p>上图是记分牌存储的信息-功能单元状态，可以得知记分牌掌控着各个功能单元的功能</p>
<blockquote>
<p>Busy表明单元是否被使用</p>
<p>Op则表示现在执行的哪一种指令</p>
<p>Fi是目的寄存器</p>
<p>Fj，Fk是源寄存器</p>
<p>Qj，Qk在确定源寄存器中没有准备好的后，表明源寄存器的值要从哪一个单元的目的寄存器中得到。</p>
<p>Rj，Rk标志Fj，Fk是否就绪，是否已经被使用</p>
</blockquote>
<p><img src="/2023/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%AE%B0%E5%88%86%E7%89%8CScoreBoard/%E8%AE%B0%E5%88%86%E7%89%8C%E5%AD%98%E5%82%A8%E7%9A%84%E4%BF%A1%E6%81%AF-%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%9C%E7%8A%B6%E6%80%81.jpg"></p>
<p>上图是记分牌存储的信息-寄存器结果状态，专门用于记录哪个寄存器要作为某功能部件的目的寄存器。如图：F4就要作为MULT部件的目的寄存器</p>
<h2 id="2、工作流程解读"><a href="#2、工作流程解读" class="headerlink" title="2、工作流程解读"></a>2、工作流程解读</h2><p>在用记分牌实现乱序执行的处理器中（这里特指 CDC 6600 处理器了），<strong>一条指令分四个阶段执行</strong>，分别是<strong>发射、读数、执行、写回</strong>。本节会逐阶段解读工作过程。</p>
<p><img src="/2023/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%AE%B0%E5%88%86%E7%89%8CScoreBoard/%E8%AE%B0%E5%88%86%E7%89%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F.jpg"></p>
<p>对示意图做一点补充，<strong>黄色方框表示流水段寄存器</strong>，分别有指令寄存器、部件寄存器（即 MUL_1 这一列）、操作数寄存器（ OPRAND ）、结果寄存器（ RESULT ）。<strong>蓝色部分是解码单元和运算单元。红色部分是寄存器堆。绿色部分是记分牌</strong>。解码单元和记分牌的交互是指解码单元要“问”记分牌当前指令是否有“ WAW 冒险”和“ Structure 结构冒险”，如果没有，指令就可以顺利渡过当前的阶段，后面的 RAW、WAR 也都是这个意思。</p>
<h3 id="ID段"><a href="#ID段" class="headerlink" title="ID段"></a>ID段</h3><p>流水线ID段被分为两级</p>
<blockquote>
<p>流出-解析指令，检查结构相关</p>
<p>读操作数一直到不存在数据相关时，才读取操作数</p>
</blockquote>
<p>如果存在WAR或者WRW相关，记分牌会暂时暂停该指令的执行，知道相关消除后才继续执行</p>
<h4 id="流出-Issue"><a href="#流出-Issue" class="headerlink" title="流出(Issue)"></a>流出(Issue)</h4><p>1.本指令所需要的功能部件有空闲</p>
<p>2.正在执行指令使用的目的寄存器与本指令不同</p>
<blockquote>
<p>保证WAW相关</p>
</blockquote>
<h4 id="读操作数-Read-operands"><a href="#读操作数-Read-operands" class="headerlink" title="读操作数(Read operands)"></a>读操作数(Read operands)</h4><p>1.前面已经流出的还在运行的指令不对本指令的源操作数寄存器进行写操作</p>
<p>2.一个正在工作的功能部件已经完成了对这个寄存器的写操作</p>
<p>3.动态解决RAW相关</p>
<p><strong>前面两步完成原来ID段的功能</strong></p>
<h4 id="执行-Execution"><a href="#执行-Execution" class="headerlink" title="执行(Execution)"></a>执行(Execution)</h4><p>1.开始于取到操作数后</p>
<p>2.当结果产生后，修改记分牌</p>
<p>3.FP流水部件会占用多个周期</p>
<h4 id="写结果-Write-result"><a href="#写结果-Write-result" class="headerlink" title="写结果(Write result)"></a>写结果(Write result)</h4><p>检查WAR相关</p>
<h4 id="出现以下情况时，不允许指令写结果："><a href="#出现以下情况时，不允许指令写结果：" class="headerlink" title="出现以下情况时，不允许指令写结果："></a>出现以下情况时，不允许指令写结果：</h4><p>1.前面的某条指令没有读取操作数</p>
<p>2.其中的某个源操作数寄存器与本指令的目的寄存器相同</p>
<h2 id="记分牌的优缺点"><a href="#记分牌的优缺点" class="headerlink" title="记分牌的优缺点"></a>记分牌的优缺点</h2><p>记分牌算法是 CDC 公司提出的一个优秀的乱序执行算法，不过记分牌本身还是有一些不小的缺点，所以在 IBM 提出 Tomasulo 算法之后，业界普遍更青睐 Tomasulo 算法。</p>
<p>记分牌算法的优点是<strong>实现了指令的乱序执行，解决了乱序执行过程中的数据冒险问题</strong>，实现了指令的数据流式运行（即数据一旦准备好就开始运行，这区别于传统五级流水线中控制运行方式），并且实现起来并不复杂。</p>
<p>但是记分牌算法还是会因为 WAR 和 WAW 冒险而产生阻塞，<strong>且一旦产生阻塞，后续相同类型的指令就没办法继续发射</strong>（在乱序执行过程中，记分牌规定每一条配置路线都只能同时存在一条指令），即图中所列的“ Limited waiting space at functional units ”，如果后续相同类型的指令没法发射，那么更后面的也许可以立马执行的指令也会被阻塞到，这对性能有很大的影响。</p>
<p>而且记分牌算法在指令完成时不是顺序的（即写回的时候不按顺序），<strong>不按顺序完成指令会对程序的调试提出挑战</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>记分牌算法由 CDC 公司在上个世纪六十年代提出，是一个实现方式简单的乱序执行算法，应用多配置流水和记分牌算法，就可以实现一个乱序执行的处理器。但是记分牌又有一些缺点，这些缺点给了 IBM 提出的 Tomasulo 算法后来居上的机会。随着学习的深入，我后面会继续更新 Tomasulo 算法的原理和算法流程。</p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>指令的动态调度</tag>
      </tags>
  </entry>
  <entry>
    <title>哥们的第一篇博客</title>
    <url>/2023/05/24/%E5%93%A5%E4%BB%AC%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2-%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h1><p>其实我开始博客的时间已经相当晚了，现在已经是大三的下学期即将画上句号，按理说能学得都已经学完了，现在正是把学到的东西实践的时刻了。可惜我学艺不精，所以决定考研这条路，也就意味着我的专业课知识得从头来过，不过这也没什么好后悔的，正好以这为教训，引以为鉴。</p>
<blockquote>
<p>种一棵树最好的时间是十年前，其次是现在。</p>
</blockquote>
<p>准备搭建博客的目的也是为此，决定将我学到的东西分享到网上，正好督促我自己的学习进度，并且这种文书工作我也并不讨厌，可以说得上相得益彰了。总之，学习的路很长，漫漫长路从脚下开始。从今天开始我会将一些学习笔记、不那么隐私的生活感悟写进我的博客，如果你看到了，请付之一笑，这些只不过是我年少的妄语，随着时间的推移，身份的改变，我自己肯定也会改变的，再回过头来看说不定也觉得现在的自己年轻幼稚。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/05/23/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
