<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数组和链表</title>
    <url>/2023/06/14/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础知识-数组与链表"><a href="#基础知识-数组与链表" class="headerlink" title="基础知识-数组与链表"></a>基础知识-数组与链表</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>数组</strong>是被操作系统分配的一个内存块，用来保存数组的元素。通过使用特定元素的索引作为数组下标，可以在常数时间内访问数组元素。</p>
<h3 id="数组的优点"><a href="#数组的优点" class="headerlink" title="数组的优点"></a>数组的优点</h3><blockquote>
<p>简单且易用</p>
<p>访问元素快(常数时间)</p>
</blockquote>
<h3 id="数组的缺点"><a href="#数组的缺点" class="headerlink" title="数组的缺点"></a>数组的缺点</h3><blockquote>
<p>大小固定：数组的大小是静态的（要在使用前指定数组的大小）</p>
<p>分配一个块：数组初始化分配空间时，有时不可能分配能存储整个数组的内存（如果数组的大小太大）</p>
<p>基于位置的插入操作实现复杂</p>
</blockquote>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是一种用于存储数据集合的数据结构。链表中相邻连续元素之间通过指针链接，最后一个元素的后继指针的值为NULL。</p>
<h3 id="链表的优点"><a href="#链表的优点" class="headerlink" title="链表的优点"></a>链表的优点</h3><blockquote>
<p>链表可以在常数时间拓展</p>
<p>在程序执行过程中，链表的大小可以增长或减小</p>
<p>链表的空间能够按需分配</p>
<p>没有内存空间的浪费</p>
</blockquote>
<h3 id="链表的缺点"><a href="#链表的缺点" class="headerlink" title="链表的缺点"></a>链表的缺点</h3><blockquote>
<p>链表的主要缺点在于访问单个元素的时间开销问题</p>
<p>存储空间的离散性降低了元素的存储效率</p>
<p>链表中的指针需要额外的内存开销</p>
</blockquote>
<h2 id="物理实现"><a href="#物理实现" class="headerlink" title="物理实现"></a>物理实现</h2><p><img src="/2023/06/14/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/%E6%95%B0%E7%BB%84.png"></p>
<p><img src="/2023/06/14/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8.png"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>6月份学习计划</title>
    <url>/2023/06/13/6%E6%9C%88%E4%BB%BD%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>现在是6月13日，已经距离期末考试的结束有过一段时间了，而且休息也休息过了，接下来就是彻底投入到考研的准备。因为避免期末不挂科，所以用了半个多月的时间一直在复习，已经很久没有碰过考研的学习了，数学和英语都有点忘却。因为首先17日要考六级，所以这几天还是以英语的复习为主，过几天再重新开始数学的复习，而且这次考试又把我分到财院校区去了，这下又得提前踩好点。另外就是18日要开始小学期了，这次小学期我选择的是数据库相关的知识，可以提前学习。</p>
<p>6月还剩下半个月，我得把数学第二轮尽快搞完，因为还有线代没学，并且政治8、9月份的时候要开始了，后面就不会分到数学太多的时间，所以得尽快完成数学的深入学习。</p>
<p>另外就是英语，很久没有搞了，得重新将英语的学习回归日常，另外现在可以多做一些原题了，计划是每周做2篇阅读题。</p>
<p>数据结构的学习还是想放到下一个月，7月份已经放暑假了，希望能够留校，这样就可以在图书馆里学习，家里确实不适合学习，也没有免费的空调蹭。</p>
]]></content>
      <categories>
        <category>计划</category>
      </categories>
  </entry>
  <entry>
    <title>基本流水线</title>
    <url>/2023/06/06/%E5%9F%BA%E6%9C%AC%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本流水线"><a href="#基本流水线" class="headerlink" title="基本流水线"></a>基本流水线</h2><h3 id="流水线的基本概念"><a href="#流水线的基本概念" class="headerlink" title="流水线的基本概念"></a>流水线的基本概念</h3><h4 id="一个任务可以分解成为k个子任务"><a href="#一个任务可以分解成为k个子任务" class="headerlink" title="一个任务可以分解成为k个子任务"></a>一个任务可以分解成为k个子任务</h4><ul>
<li><p>k个子任务在k个不同阶段(使用不同的资源)运行</p>
</li>
<li><p>每个子任务执行需要1个单位时间</p>
</li>
<li><p>整个任务的执行时间为k倍单位时间</p>
</li>
</ul>
<h4 id="流水线执行模式是重叠执行模式"><a href="#流水线执行模式是重叠执行模式" class="headerlink" title="流水线执行模式是重叠执行模式"></a>流水线执行模式是重叠执行模式</h4><ul>
<li><p>k个流水段，并行执行k个不同任务</p>
</li>
<li><p>每个单位时间，一个任务进入&#x2F;离开流水线</p>
</li>
</ul>
<p><img src="/2023/06/06/%E5%9F%BA%E6%9C%AC%E6%B5%81%E6%B0%B4%E7%BA%BF/%E6%B5%81%E6%B0%B4%E7%BA%BF.png"></p>
<h3 id="同步流水线"><a href="#同步流水线" class="headerlink" title="同步流水线"></a>同步流水线</h3><ul>
<li><p><strong>流水段之间采用时钟控制的寄存器文件</strong></p>
</li>
<li><p><strong>时钟上升沿到达时…</strong></p>
</li>
</ul>
<p>-所有寄存器同时保存前一流水段的结果</p>
<ul>
<li><p><strong>流水段是组合逻辑电路</strong></p>
</li>
<li><p><strong>流水线设计中希望各段相对平衡</strong></p>
</li>
</ul>
<p><img src="/2023/06/06/%E5%9F%BA%E6%9C%AC%E6%B5%81%E6%B0%B4%E7%BA%BF/%E6%B5%81%E6%B0%B4%E6%AE%B5.png"></p>
<h3 id="流水线的性能"><a href="#流水线的性能" class="headerlink" title="流水线的性能"></a>流水线的性能</h3><p>• 设 τi&#x3D;time delay in stage Si</p>
<p>• 时钟周期 τ &#x3D;max(τi) 为最长的流水段延迟</p>
<p>• 时钟频率 f &#x3D; 1&#x2F;τ &#x3D; 1&#x2F;max(τi)</p>
<p>• 流水线可以在k+n-1个时钟周期内完成n个任务</p>
<p>  – 完成第一个任务需要 k个时钟周期</p>
<p>  – 其他n-1个任务，在后续的n-1个时钟周期完成</p>
<p>• K-段流水线的理想加速比（相对于串行执行）</p>
<p><img src="/2023/06/06/%E5%9F%BA%E6%9C%AC%E6%B5%81%E6%B0%B4%E7%BA%BF/k%E6%AE%B5%E6%B5%81%E6%B0%B4%E7%BA%BF.png"></p>
<h3 id="典型的RISC-5段指令流水"><a href="#典型的RISC-5段指令流水" class="headerlink" title="典型的RISC 5段指令流水"></a>典型的RISC 5段指令流水</h3><ul>
<li><p><strong>五个流水段，每段的延迟为1个cycle</strong></p>
</li>
<li><p><strong>IF：取指阶段</strong></p>
<p>-选择地址：下一条指令地址、转移地址</p>
</li>
<li><p><strong>ID：译码阶段</strong></p>
<p>-确定控制信号并从寄存器文件中读取寄存器值</p>
</li>
<li><p><strong>EX：执行</strong></p>
<p>-Load&#x2F;Store:计算有效地址</p>
<p>-Branch：计算转移地址并确定转移方向</p>
</li>
<li><p><strong>MEM：存储器访问(仅Load和Store)</strong></p>
</li>
<li><p><strong>WB：结果写回</strong></p>
</li>
</ul>
<p><img src="/2023/06/06/%E5%9F%BA%E6%9C%AC%E6%B5%81%E6%B0%B4%E7%BA%BF/RISC5.png"></p>
<h3 id="流水线的可视化表示"><a href="#流水线的可视化表示" class="headerlink" title="流水线的可视化表示"></a>流水线的可视化表示</h3><h4 id="多条指令执行多个时钟周期"><a href="#多条指令执行多个时钟周期" class="headerlink" title="多条指令执行多个时钟周期"></a>多条指令执行多个时钟周期</h4><ul>
<li><p>指令按程序从上到下排序</p>
</li>
<li><p>图中展示了每一时钟周期资源的使用情况</p>
</li>
<li><p>不同指令相邻阶段之间没有干扰</p>
</li>
</ul>
<p><img src="/2023/06/06/%E5%9F%BA%E6%9C%AC%E6%B5%81%E6%B0%B4%E7%BA%BF/%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8F%AF%E8%A7%86%E5%8C%96.png"></p>
<h3 id="指令流时序"><a href="#指令流时序" class="headerlink" title="指令流时序"></a>指令流时序</h3><h4 id="时序图展示："><a href="#时序图展示：" class="headerlink" title="时序图展示："></a>时序图展示：</h4><ul>
<li>每个时钟周期指令所使用的流水段情况</li>
</ul>
<h4 id="指令流在采用5段流水线执行模式的执行情况"><a href="#指令流在采用5段流水线执行模式的执行情况" class="headerlink" title="指令流在采用5段流水线执行模式的执行情况"></a>指令流在采用5段流水线执行模式的执行情况</h4><p><img src="/2023/06/06/%E5%9F%BA%E6%9C%AC%E6%B5%81%E6%B0%B4%E7%BA%BF/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%97%B6%E5%BA%8F.png"></p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>流水线</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习</title>
    <url>/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="学习概述"><a href="#学习概述" class="headerlink" title="学习概述"></a>学习概述</h1><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>机器可以自动”学习”的算法，即从<strong>数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。</strong></p>
<h2 id="学习的反馈类型"><a href="#学习的反馈类型" class="headerlink" title="学习的反馈类型"></a>学习的反馈类型</h2><h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>不提供任何的显示反馈，比如：KNN聚类算法</p>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0.png"></p>
<h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p>提供“输入-输出”对，学习从输入到输出的映射函数。比如：贝叶斯网络，人工神经网络，决策树</p>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0.png"></p>
<h3 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h3><p>提供少量的“输入-输出”对，大部分样本未标注。基于图的学习算法。</p>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0.png"></p>
<h2 id="监督学习-1"><a href="#监督学习-1" class="headerlink" title="监督学习"></a>监督学习</h2><h3 id="监督学习的任务是："><a href="#监督学习的任务是：" class="headerlink" title="监督学习的任务是："></a>监督学习的任务是：</h3><p>1.给定由N个“输入-输出”对样例组成的训练集从给定的训练数据集中学习出一个函数（模型参数）</p>
<p>2.当新的数据到来时，可以根据这个函数预测结果</p>
<h3 id="分类与回归"><a href="#分类与回归" class="headerlink" title="分类与回归"></a>分类与回归</h3><p>分类问题的主要目的是预测分类标签，标签来自预定义的可选列表。分类问题可分为二分类和多分类。</p>
<p>比如邮件系统，对于垃圾邮件的识别就是一个分类问题。</p>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%88%86%E7%B1%BB.png"></p>
<p>回归任务的目标是预测一个连续值。</p>
<p>例如，根据教育水平、年龄和居住地来预测一个人的年收入，预测的结果是一个金额数值。</p>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E5%BD%92.png"></p>
<h2 id="K-折交叉验证"><a href="#K-折交叉验证" class="headerlink" title="K-折交叉验证"></a>K-折交叉验证</h2><p>思想：每个样本既作为训练数据，又作为测试数据</p>
<blockquote>
<p>将数据分成k个相等的子集</p>
<p>执行k轮次学习，每一轮1&#x2F;k个数据作为测试数据，其他作为训练数据</p>
</blockquote>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/K.png"></p>
<p>精度增加伴随着代价增加</p>
<h2 id="过拟合-x2F-欠拟合"><a href="#过拟合-x2F-欠拟合" class="headerlink" title="过拟合&#x2F;欠拟合"></a>过拟合&#x2F;欠拟合</h2><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><p>拟合模型时，过分关注训练集的细节，训练集学习得到的目标函数在训练集上性能很好，在测试集上性能不高。</p>
<p>训练出的模型太复杂，不能泛化到新数据上的模型就叫做过拟合。</p>
<p>其实就是训练次数过多导致找到了太多只适用于训练集的特征，过于细化所以不能通用。</p>
<h3 id="欠拟合"><a href="#欠拟合" class="headerlink" title="欠拟合"></a>欠拟合</h3><p>相反，如果模型过于简单，那么就可能无法抓住数据的全部内容以及数据中的变化。甚至可能模型在训练集上的表现也很差。也就是没要找到特征。</p>
<h3 id="如何避免过拟合"><a href="#如何避免过拟合" class="headerlink" title="如何避免过拟合"></a>如何避免过拟合</h3><ol>
<li>Early stopping （适当的stoppingcriterion）:</li>
</ol>
<p>   Early stopping便是一种迭代次数截断的方法来防止过拟</p>
<p>   合的方法，即在模型对训练数据集迭代收敛之前停止迭代</p>
<p>   来防止过拟合</p>
<p>   2) 数据集扩增 : 数据机扩增即需要得到更多的符合要求</p>
<p>   的数据，即和已有的数据是独立同分布的，或者近似独立</p>
<p>   同分布的。一般方法有：从数据源头采集更多数据，复制</p>
<p>   原有数据并加上随机噪声，重采样，根据当前数据集估计</p>
<p>   数据分布参数，使用该分布产生更多数据等</p>
<p>   3）正则化方法：一般有L1正则与L2正则等</p>
<p>   4）Dropout：正则是通过在代价函数后面加上正则项来防</p>
<p>   止模型过拟合的。而在神经网络中，有一种方法是通过修</p>
<p>   改神经网络本身结构来实现的，其名为Dropout。</p>
<h2 id="信息理论：熵"><a href="#信息理论：熵" class="headerlink" title="信息理论：熵"></a>信息理论：熵</h2><p>熵H(x)：衡量数据集的纯度</p>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%86%B5.png"></p>
<p>熵曲线</p>
<p>两个样本(P,N),p个正样本数，n个负样本数，p&#x3D;9,n&#x3D;5</p>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%86%B5%E6%9B%B2%E7%BA%BF.png"></p>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%86%B5%E6%A0%B7%E4%BE%8B.png"></p>
<h2 id="信息理论：属性选择"><a href="#信息理论：属性选择" class="headerlink" title="信息理论：属性选择"></a>信息理论：属性选择</h2><p>根据熵的定义，公平掷硬币的熵：</p>
<p>$$<br>H(Fair)&#x3D;− (0.5log_2⁡0.5 +0.5  log_2⁡0.5 )&#x3D; 1<br>$$</p>
<p>如果加载硬币，使之能掷出99%正面向上，则有</p>
<p>$$<br>H(Loaded)&#x3D;− (0.99log_2⁡0.99+0. 01log_2⁡0.01) ≈0.08<br>$$</p>
<p>设布尔变量以q的概率为真，则可定义该变量的熵为：</p>
<p>$$<br>B(q)&#x3D;− (q log_2⁡q +(1-q)log_2⁡(1-q) )<br>$$</p>
<p>因此</p>
<p>$$<br>H(Loaded)&#x3D;B(0.99)≈0.08<br>$$</p>
<p>一个训练数据集包含p个正样本,n个负样本，则目标属性在整个样例集上的熵为：</p>
<p>$$<br>H(Goal)&#x3D; B(𝑝&#x2F;(𝑝+𝑛))<br>$$</p>
<p>一个属性A的取值为A1,A2,…,Av,根据属性A的取值将训练数据集E分成E1,E2,…Ev,每个子集Ei有pi个正例和ni个反例，则选择属性A后，剩余的期望熵值为：</p>
<p><img src="/2023/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%9B%E7%86%B5%E5%80%BC.png"></p>
<p>属性A的信息收益是<strong>熵的期望减少</strong>，即原有的熵值-属性A分裂后的熵值：</p>
<p>$$<br>Gain(A)&#x3D; B(𝑝&#x2F;(𝑝+𝑛)) - H(A)<br>$$</p>
<p>$$<br>Gain(Patrons)&#x3D; 1−[2&#x2F;12B(0&#x2F;2)+4&#x2F;12B(4&#x2F;4)+6&#x2F;12B(2&#x2F;6)]≈0.541</p>
<p>$$</p>
<p>$$<br>Gain(Type)&#x3D; 1−[2&#x2F;12B(1&#x2F;2)+2&#x2F;12B(1&#x2F;2)+4&#x2F;12B(2&#x2F;4)+4&#x2F;12B(2&#x2F;4)]&#x3D;0<br>$$</p>
<p>$$<br>Gain(Patrons)&gt;Gain(Type)<br>$$</p>
<p><strong>选择信息收益最大的属性进行分裂</strong></p>
<h2 id="决策树剪枝"><a href="#决策树剪枝" class="headerlink" title="决策树剪枝"></a>决策树剪枝</h2><p>找到<strong>过度拟合</strong>的结点，删除该节点及其分支</p>
<p>如果一个节点是过度拟合的，则该结点不同属性之下所含正样本的比例与整个集合的比例大致相同，<strong>pk&#x2F;(pk+nk)≈p&#x2F;(p+n)</strong></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
  </entry>
  <entry>
    <title>朴素贝叶斯分类算法</title>
    <url>/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>贝叶斯分类是一类分类算法的总称，算法以贝叶斯定理为基础，所以称为贝叶斯分类。本文将首先介绍分类问题，对分类问题进行一个正式的定义。然后，介绍贝叶斯分类算法的基础——贝叶斯定理。最后，通过实例讨论贝叶斯分类中最简单的一种：朴素贝叶斯分类。</p>
<h1 id="二、分类问题介绍"><a href="#二、分类问题介绍" class="headerlink" title="二、分类问题介绍"></a>二、分类问题介绍</h1><p>分类，顾名思义，就是把集合分出类别来，比如人类可以分为黄种人、白种人、黑种人。</p>
<p>在数学方面可以做如下定义：</p>
<p>已知集合：</p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E9%9B%86%E5%90%881.png"></p>
<p>和<img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E9%9B%86%E5%90%882.png"></p>
<p>确定映射规则<img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E6%98%A0%E5%B0%84%E8%A7%84%E5%88%99.png"></p>
<p>使得任意有<img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/1.png"></p>
<p>且仅有一个</p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/2.png"></p>
<p>使得<img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/3.png"></p>
<p>成立<br>        其中C叫做类别集合，其中每一个元素是一个类别，而I叫做项集合，其中每一个元素是一个待分类项，f叫做分类器。分类算法的任务就是构造分类器f。<br>        值得注意的是，分类问题常常采用经验性方法构造映射规则，及一般情况下的分类问题缺少足够的信息来构造百分百正确的映射规则，而是通过对经验数据的学习从而实现一定概率意义上的正确的分类，因此从训练出的分类器并不是一定能准确地将每个待分类项映射到其分类，分类器的质量与分类器构造方法、待分类数据的特性以及数据样本数量等诸多因素相关。</p>
<h1 id="朴素贝叶斯算法前提说明"><a href="#朴素贝叶斯算法前提说明" class="headerlink" title="朴素贝叶斯算法前提说明"></a>朴素贝叶斯算法前提说明</h1><p>朴素贝叶斯算法成立的前提：<strong>各属性之间相互独立</strong>。当数据集满足这种独立性假设时，分类的准确度较高，否则可能较低。</p>
<h1 id="贝叶斯定理理论基础"><a href="#贝叶斯定理理论基础" class="headerlink" title="贝叶斯定理理论基础"></a>贝叶斯定理理论基础</h1><p>贝叶斯定理是关于随机事件（或边缘概率）的一则定理。这个定理解决了现实生活里经常遇到的问题：已知某条件概率，如何得到两个事件交换后的概率，也就是在已知P(A|B)的情况下如何求得P(B|A)</p>
<p>贝叶斯定理之所以有用，是因为我们在生活中经常遇到这种情况：我们可以很容易直接得出P(A|B)，P(B|A)则很难直接得出，但我们更关心P(B|A)，贝叶斯定理就为我们打通从P(A|B)获得P(B|A)的道路。</p>
<p>下面不加证明地直接给出贝叶斯定理：</p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E8%B4%9D%E5%8F%B6%E6%96%AF.png"></p>
<h1 id="朴素贝叶斯分类的原理和流程"><a href="#朴素贝叶斯分类的原理和流程" class="headerlink" title="朴素贝叶斯分类的原理和流程"></a>朴素贝叶斯分类的原理和流程</h1><h2 id="思想基础"><a href="#思想基础" class="headerlink" title="思想基础"></a>思想基础</h2><p>朴素贝叶斯的思想基础：对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，就认为此待分类项属于哪个类别。就比如说你在大街上见到一个黑哥们，你肯定首先认为他是个非洲人，但实际上黑人非洲、亚洲、美洲都有。但是非洲的黑人最多概率最大，所以你会认为他是个非洲人。</p>
<h2 id="图示流程"><a href="#图示流程" class="headerlink" title="图示流程"></a>图示流程</h2><p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E6%B5%81%E7%A8%8B.png"></p>
<h2 id="正式定义"><a href="#正式定义" class="headerlink" title="正式定义"></a>正式定义</h2><p>1.设   <img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E5%BE%85%E5%88%86%E7%B1%BB%E9%A1%B9.png">为一个待分类项，而每个a为x的一个特征属性</p>
<p>2.有类别集合<img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E9%9B%86%E5%90%881.png"></p>
<p>3.计算</p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%971.png"></p>
<p>4.如果<img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%972.png"></p>
<p>那么x∈yk</p>
<p>现在的关键就是如何计算第三步的各个条件概率。可以这样做：</p>
<p>1、找到一个已知分类的待分类项集合，这个集合叫做训练样本集。</p>
<p>2、统计得到在各类别下各个特征属性的条件概率估计。即：</p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%973.png"></p>
<p>3、如果各个特征属性是条件独立的，则根据贝叶斯定理有如下推导：<img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E6%8E%A8%E5%AF%BC.png"></p>
<p>因为分母对所有的类别为常数，因此我们将分子最大化即可。又因为各特征属性是条件独立的，所以有：</p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E7%BB%93%E8%AE%BA.png"></p>
<p> 可以看到，整个朴素贝叶斯分类分为三个阶段：</p>
<p>      第一阶段——准备工作阶段，这个阶段的任务是为朴素贝叶斯分类做必要的准备，主要工作是根据具体情况确定特征属性，并对每个特征属性进行适当划分，然后由人工对一部分待分类项进行分类，形成训练样本集合。这一阶段的输入是所有待分类数据，输出是特征属性和训练样本。这一阶段是整个朴素贝叶斯分类中唯一需要人工完成的阶段，其质量对整个过程将有重要影响，分类器的质量很大程度上由特征属性、特征属性划分及训练样本质量决定。</p>
<p>      第二阶段——分类器训练阶段，这个阶段的任务就是生成分类器，主要工作是计算每个类别在训练样本中的出现频率及每个特征属性划分对每个类别的条件概率估计，并将结果记录。其输入是特征属性和训练样本，输出是分类器。这一阶段是机械性阶段，根据前面讨论的公式可以由程序自动计算完成。</p>
<p>      第三阶段——应用阶段。这个阶段的任务是使用分类器对待分类项进行分类，其输入是分类器和待分类项，输出是待分类项与类别的映射关系。这一阶段也是机械性阶段，由程序完成。</p>
<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>这一节讨论P(a|y)的估计。</p>
<p>      由上文看出，计算各个划分的条件概率P(a|y)是朴素贝叶斯分类的关键性步骤，当特征属性为离散值时，只要很方便的统计训练样本中各个划分在每个类别中出现的频率即可用来估计P(a|y)，下面重点讨论特征属性是连续值的情况。</p>
<p>      当特征属性为连续值时，通常假定其值服从高斯分布（也称正态分布）。即：</p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83.png"></p>
<p>因此只要计算出训练样本中各个类别中此特征项划分的各均值和标准差，代入上述公式即可得到需要的估计值。均值与标准差的计算在此不再赘述。</p>
<p>      另一个需要讨论的问题就是当P(a|y)&#x3D;0怎么办，当某个类别下某个特征项划分没有出现时，就是产生这种现象，这会令分类器质量大大降低。为了解决这个问题，我们引入Laplace校准，它的思想非常简单，就是对没类别下所有划分的计数加1，这样如果训练样本集数量充分大时，并不会对结果产生影响，并且解决了上述频率为0的尴尬局面。</p>
<h3 id="实验：汽车估计数据集"><a href="#实验：汽车估计数据集" class="headerlink" title="实验：汽车估计数据集"></a>实验：汽车估计数据集</h3><p>一．数据描述：</p>
<p>n汽车评估数据集包含1728个数据，其中训练数据1350，测试数据 378个。每个数据包含6个属性，所有的数据分为4类：</p>
<p>ClassValues: unacc, acc,good, vgood</p>
<p>Attributes:</p>
<p>buying: vhigh,high, med, low.</p>
<p>maint: vhigh,high, med, low.</p>
<p>doors:2, 3, 4, 5more.</p>
<p>persons:2, 4, more.</p>
<p>lug_boot:small, med, big.</p>
<p>safety:low, med, high.</p>
<p>未校准：</p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E6%9C%AA%E6%A0%A1%E5%87%861.png"></p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E6%9C%AA%E6%A0%A1%E5%87%862.png"></p>
<p>校准后：</p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E6%A0%A1%E5%87%861.png"></p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E6%A0%A1%E5%87%862.png"></p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E4%BE%8B%E9%A2%98.png"></p>
<p><img src="/2023/05/27/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/%E7%AD%94.jpg"></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>贝叶斯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>监听法和目录法</title>
    <url>/2023/05/27/%E7%9B%91%E5%90%AC%E6%B3%95%E5%92%8C%E7%9B%AE%E5%BD%95%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>计算机体系结构-Tomasulo算法</title>
    <url>/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Tomasulo%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-与记分牌算法的比较"><a href="#1-与记分牌算法的比较" class="headerlink" title="1.与记分牌算法的比较"></a>1.与记分牌算法的比较</h2><h3 id="1-1-重新审视数据冒险"><a href="#1-1-重新审视数据冒险" class="headerlink" title="1.1    重新审视数据冒险"></a>1.1    重新审视数据冒险</h3><p><strong>假数据冒险影响了记分牌算法的乱序性能</strong>。</p>
<p>那么什么是假数据冒险呢？</p>
<p>我们都知道，数据冒险有WAW,WAR,RAR,RAW这四种，而其中RAR其实在流水线中并没有影响指令的执行，所以可以把它忽略。</p>
<p>在剩下三个之中，只有RAW“写后读”才是真冒险，而WAR和WAW都是假冒险。为什么呢？因为这两种冒险都是在第一个操作后进行写操作，说明写操作的目标寄存器是被使用的状态，所以必须阻塞自己才能不引发冲突。而解决方法其实很简单，只要把写操作的目标寄存器改变成没有冲突的寄存器就可以解决。</p>
<p>但是<strong>RAW是无解的</strong>，因为后续指令读取的数据必须由前序指令算的，有明显的数据依赖，所以才是”真冒险”</p>
<p><strong>这三种冒险的差别就出现在”数据依赖方面”<strong>。读后写”和“写后写”通过改写寄存器名字就可以消除冒险，这表明这两种冒险其实没有数据依赖，</strong>即发生冒险的指令之间其实没有数据流动</strong>。想要挖掘出指令的乱序潜力，理解这一点非常重要。</p>
<p><strong>综上所述，“写后写”和“读后写”冒险不是真冒险，没必要为他们阻塞指令的流动</strong></p>
<p>例子：</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Tomasulo%E7%AE%97%E6%B3%95/%E7%A4%BA%E4%BE%8B1.jpg"></p>
<p>首先看“写后写”WAW冒险，可以看到第一条、第三条指令都要写R3寄存器，犯了“写后写”冒险。在记分牌中如果遇到这种情况，后序的AND指令因为和ADD指令发生“写后写”冒险，所以无法发射，流水线在发射阶段堵塞。</p>
<p><strong>但是如果把AND指令的目的寄存器改写成R10，那么冒险就消除了</strong>，AND指令可以发射，只不过写回的目的寄存器是R10而不是R3。</p>
<p>同样的，审视“读后写”WAR冒险。第一条指令和第二条指令关于R3发生了“读后写”冒险，在记分牌中如果碰到这种情况，第二条指令在写回阶段时会检测到第一条指令需要读取R3旧值，所以第二条指令会卡在写回阶段，直到第一条指令读取完R3并且通知到自己为止。</p>
<p><strong>如果把第二条指令的R3改写成R10，冒险就又解决了</strong>，第一条指令可以去读R3，第二条指令的更新结果存在R10，不会覆盖R3的旧值。</p>
<h3 id="1-2-Tomasulo算法与记分牌"><a href="#1-2-Tomasulo算法与记分牌" class="headerlink" title="1.2     Tomasulo算法与记分牌"></a>1.2     Tomasulo算法与记分牌</h3><p>记分牌存在巨大的缺点，每个运算部件只有一个译码信息流水段寄存器，这意味着多配置处理器中的每一条配置通路同一时间只能存在一条指令，如果某一配置通路被占据，那么后面所有的指令都要被阻塞。</p>
<p><strong>而且记分牌为了乱序执行指令，在碰到写后写、读后写这两个冒险的时候也会暂停流水线（为什么这里不提写后读呢，见后文），而这其实是不必要的，因此记分牌算法还是没有最大限度地挖掘出指令的乱序潜力</strong>。而且记分牌的“写回”是乱序的，乱序完成指令不利于处理器处理中断、异常等情况，不利于程序员debug程序。</p>
<p>Tomasulo采用了许多记分牌中的理念</p>
<p>两个较大的差异</p>
<blockquote>
<p><strong>Tomasulo算法中，冲突检测和执行控制是分布的，利用保留站实现</strong></p>
<p><strong>Tomasulo算法不用检查WAR和WAW相关，已经使用算法本身消除掉了</strong></p>
</blockquote>
<h3 id="寄存器重命名"><a href="#寄存器重命名" class="headerlink" title="寄存器重命名"></a>寄存器重命名</h3><p><strong>消除假数据相关的主要方法是寄存器重命名</strong>。</p>
<p>寄存器重命名其实就是修改寄存器的名字，防止寄存器冲突。那么就意味着需要在原来寄存器的基础上额外有寄存器。</p>
<p>实现额外寄存器的方法有两种</p>
<p>可以在逻辑寄存器（MIPS指令集规定了32个逻辑寄存器）之外额外有一组物理寄存器，结构如图。假如逻辑寄存器正要被改写或被读，就置Busy位为1，并通过Tag指示最新数据将被写到哪一个物理寄存器。通过这样的方法，我们可以在新数据计算完毕时立刻写回，同时也允许前序指令读取寄存器旧值（因为旧值没有被覆盖，它还存在于逻辑寄存器中）。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Tomasulo%E7%AE%97%E6%B3%95/%E7%A4%BA%E4%BE%8B2.jpg"></p>
<p>上面这种方法把逻辑寄存器和物理寄存器分离开，其实完全可以把两者混合起来，即为处理器提供超过逻辑寄存器数量的寄存器，如MIPS指令集要求32个逻辑寄存器，那就设计40个物理寄存器给处理器，至于哪些寄存器是ISA要求的32个寄存器，则视程序运行情况而定，相关信息可以用一个表格存储起来，理论上任何一个物理寄存器都可能是任何一个逻辑寄存器。</p>
<p>上面简单说明了两种寄存器重命名的方法，Tomasulo算法采用了第一种，但是不彻底，<strong>说Tomasulo算法蕴含寄存器重命名的思想则更合适。</strong></p>
<h2 id="2-Tomasulo算法"><a href="#2-Tomasulo算法" class="headerlink" title="2. Tomasulo算法"></a>2. Tomasulo算法</h2><h3 id="2-1-Tomasulo算法产生的背景"><a href="#2-1-Tomasulo算法产生的背景" class="headerlink" title="2.1 Tomasulo算法产生的背景"></a>2.1 Tomasulo算法产生的背景</h3><h4 id="IBM-360-x2F-91比CDC6600-记分牌算法-晚三年推出"><a href="#IBM-360-x2F-91比CDC6600-记分牌算法-晚三年推出" class="headerlink" title="IBM 360&#x2F;91比CDC6600(记分牌算法)晚三年推出"></a>IBM 360&#x2F;91比CDC6600(记分牌算法)晚三年推出</h4><p>商业计算机使用cache技术之前</p>
<h4 id="整个360系列仅一个指令系统和一个编译器"><a href="#整个360系列仅一个指令系统和一个编译器" class="headerlink" title="整个360系列仅一个指令系统和一个编译器"></a>整个360系列仅一个指令系统和一个编译器</h4><p>要求具有很高的浮点性能，但不是通过高端机器的专用的编译器实现</p>
<p>只有四个双精度浮点寄存器，编译器调度的有效性受到很大限制</p>
<p>访存时间和浮点计算时间都很长</p>
<p>可支持循环的多次迭代重叠执行</p>
<h3 id="2-2-Tomasulo算法的结构"><a href="#2-2-Tomasulo算法的结构" class="headerlink" title="2.2    Tomasulo算法的结构"></a>2.2    Tomasulo算法的结构</h3><p><strong>Tomasulo最大的特点就是通过借助重命名的思想消除了假数据冒险，从而提高了机器的乱序性能</strong>。</p>
<p>先看这个结构：</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Tomasulo%E7%AE%97%E6%B3%95/%E7%A4%BA%E4%BE%8B3.jpg"></p>
<ul>
<li>首先是FP OP Queue，这里是浮点指令队列，指令在这里等待发射；</li>
<li>青绿色模块是加法单元和乘法单元的保留站（保留站是什么？保留站保留已经发射的指令的信息和缓冲下来的数据。关于保留站，后文会有更多介绍）；</li>
<li>蓝绿色的Address Unit是地址计算单元，在这个算法中存储指令在执行前会先计算好存储地址；</li>
<li>Memory Unit则是存储单元；</li>
<li>CDB是数据广播总线，它可以直达寄存器堆（用来更新通用寄存器）、加法乘法存储单元的保留站（输送保留站中指令需要的数据）。</li>
</ul>
<p>要解读Tomasulo算法，<strong>就要搞清楚这个算法运用了哪些信息来调度指令，然后要分清楚算法的调度步骤</strong>。接下来首先解释Tomasulo算法利用了哪些信息，然后讲解算法的调度步骤。</p>
<h4 id="2-2-1-保留站和寄存器结果状态表"><a href="#2-2-1-保留站和寄存器结果状态表" class="headerlink" title="2.2.1  保留站和寄存器结果状态表"></a>2.2.1  保留站和寄存器结果状态表</h4><p>保留站是Tomasulo算法的精髓，不同于记分牌每一个配置通路前面的译码信息流水段寄存器，记分牌中每一条配置通路只能存放一条指令，<strong>而Tomasulo算法则为每一条通路配置了一组缓冲</strong>。就像上图中的绿色模块，其中浮点加法单元拥有能够缓冲三条指令的保留站。保留站存储的信息和记分牌有点类似。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Tomasulo%E7%AE%97%E6%B3%95/%E7%A4%BA%E4%BE%8B4.jpg"></p>
<p>保留站的结构有点像cache，可能有多行数据，每一行都对应一条被发射到保留站的指令。保留站每一行都有Busy位，指示这一行是否现存有指令；Vj和Vk与记分牌不同，记分牌的Vj和Vk会记录源寄存器的编号，<strong>而保留站则直接把能读取的数据直接拷贝到保留站中</strong>，可想而知，一旦数据进入保留站，那对应的寄存器就和这条指令没瓜葛了；Qj和Qk的信息和记分牌一样，记录尚不能读取的数据将由哪条指令算出；A是存储指令的地址，用于存放立即数和计算得到的地址数据。</p>
<p>看上去保留站和记分牌非常相似，但是两者其实有很大的不同。以上图的Add为例，保留站中有三行Add信息，这三行数据对应的是同一个加法单元，而在记分牌中这代表着三个加法单元。记分牌那样的一条通路只对应一条信息的做法容易造成指令堵塞、无法发射，<strong>而保留站则为每条通路预留了缓冲区，指令可以在加法单元忙碌的时候发射到保留站的缓冲区待命</strong>。</p>
<p>其次，保留站会直接把读取的数据缓冲下来，而不像记分牌一样只记录一个寄存器编号，只记录编号的话会造成读后写阻塞，因为一条指令在正式执行前一直在监控着它的源寄存器，源寄存器的值是不能改变的，因此后续指令无法写回，只能阻塞流水，<strong>而保留站则贯彻了“数据一旦准备完毕，就立马执行指令”的思想</strong>，指令一旦发现有数据可读，就立马读下来，读下来之后，那个源寄存器的写与不写就不关己事了。</p>
<p>记分牌和保留站相同的地方是都记录了Qj和Qk，即一旦需要的数据被算出来，就通过Qj和Qk捕捉广播数据，<strong>这样的做法其实就是重命名，即用保留站的编号而不是寄存器编号来标记数据源</strong>。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Tomasulo%E7%AE%97%E6%B3%95/%E7%A4%BA%E4%BE%8B6.jpg"></p>
<p>除了保留站数据结构之外，Tomasulo同样要记录寄存器结果状态，记录信息如图6.和记分牌一样，Tomasulo也会记录寄存器将被哪条指令更新，这个信息在指令寻找源数据时被使用。</p>
<h4 id="2-2-2-调度流程"><a href="#2-2-2-调度流程" class="headerlink" title="2.2.2  调度流程"></a>2.2.2  调度流程</h4><h5 id="MIPS五阶段的流水线的改造"><a href="#MIPS五阶段的流水线的改造" class="headerlink" title="MIPS五阶段的流水线的改造"></a>MIPS五阶段的流水线的改造</h5><p>ID和EX阶段被以下三个阶段代替</p>
<p>1.流出(Issue)</p>
<p>2.执行(Execute)</p>
<p>3.结果写回(Write result)</p>
<h5 id="流出-Issue"><a href="#流出-Issue" class="headerlink" title="流出(Issue)"></a>流出(Issue)</h5><p>1.从浮点指令队列中取出一条指令</p>
<p>2.如果存在一个空的保留站，就流出这条指令</p>
<p>3.如果操作数在寄存器中，就送到该指令对应的保留站</p>
<p>4.存储器取&#x2F;存指令只要有空闲的缓存就可以流出</p>
<p>5.如果没有空闲的保留站或者缓存，就存在结构相关，指令暂停，直到有空闲的保留站或者缓存</p>
<h5 id="执行-Execute"><a href="#执行-Execute" class="headerlink" title="执行(Execute)"></a>执行(Execute)</h5><p>1.如果缺少一个或者多个操作数，就监听CBD</p>
<blockquote>
<p>这个阶段实际是检测和自动维护RAW相关</p>
</blockquote>
<p>2.如果两个操作数都就绪，这条指令就可以执行</p>
<h5 id="结果写回-Write-result"><a href="#结果写回-Write-result" class="headerlink" title="结果写回(Write result)"></a>结果写回(Write result)</h5><p>1.如果结果已经产生，将其写到CBD上</p>
<p>2.通过CDB,把这个结果写到目标寄存器和等待这个结果的所有功能单元的保留站</p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>指令的动态调度</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机体系结构-记分牌ScoreBoard</title>
    <url>/2023/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%AE%B0%E5%88%86%E7%89%8CScoreBoard/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-什么是记分牌"><a href="#1-什么是记分牌" class="headerlink" title="1.什么是记分牌"></a>1.什么是记分牌</h2><p>首先需要认识到一个事实：<strong>顺序执行的处理器有瑕疵</strong></p>
<p>比如说lw指令后面跟着一连串与它无关的指令，但是lw指令发生了 data cache miss 的情况，导致了必须访问主存，所以就很慢，但是它卡在访存阶段几十上百个周期，如果是顺序执行，后面的指令会等他结束在执行，效率太低，<strong>如果想要实现“继续执行”，即后面的指令“绕过” lw 指令继续执行，那么就需要处理器支持乱序</strong></p>
<h3 id="1-1-乱序执行"><a href="#1-1-乱序执行" class="headerlink" title="1.1 乱序执行"></a>1.1 乱序执行</h3><p>顺序执行的效率太慢，如果有一条指令阻塞，那么后面所有的指令都会阻塞，所以设计师开了几条近道，让后面的指令可以绕过前面的指令，从而继续执行。</p>
<p>在乱序情况下，<strong>只要一条指令所需要的数据准备好了，那么就执行这条指令</strong>，而不用像顺序执行一样既要准备好数据，又要前面的指令把”路“让出来。</p>
<h3 id="1-2-多配置流水"><a href="#1-2-多配置流水" class="headerlink" title="1.2 多配置流水"></a>1.2 多配置流水</h3><p>传统的五级流水线中，所有的指令都要走完运算通路，计算指令不需要访问存储器，所以完全可以绕开存储器，但正是因为这样的规定，导致前面的lw指令卡在了访存环节中，导致计算指令只能等lw指令把存储器让出来。</p>
<p>所以就有了<strong>多配置流水</strong>，针对不同的计算指令的不同的要求，为之开辟不同的道路，有这些路指令就可以实现超车。<strong>多配置流水的处理器可以实现乱序执行。</strong></p>
<h3 id="1-3-记分牌算法"><a href="#1-3-记分牌算法" class="headerlink" title="1.3 记分牌算法"></a>1.3 记分牌算法</h3><p>下面是CDC 6600 的结构示意：</p>
<p><img src="/2023/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%AE%B0%E5%88%86%E7%89%8CScoreBoard/CDC6600%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F.jpg"></p>
<p>可以看到有两个浮点乘法器(FP mult)，一个浮点除法器(FP divide)，一个浮点加法器(FP add)，一个整型单元(Integer unit:用于计算存储地址)，和记分牌(Scoreboard),记分牌是信息存储单元，接下来两张图解释它究竟什么功能。</p>
<p><img src="/2023/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%AE%B0%E5%88%86%E7%89%8CScoreBoard/%E8%AE%B0%E5%88%86%E7%89%8C%E5%AD%98%E5%82%A8%E7%9A%84%E4%BF%A1%E6%81%AF-%E5%8A%9F%E8%83%BD%E5%8D%95%E5%85%83%E7%8A%B6%E6%80%81.jpg"></p>
<p>上图是记分牌存储的信息-功能单元状态，可以得知记分牌掌控着各个功能单元的功能</p>
<blockquote>
<p>Busy表明单元是否被使用</p>
<p>Op则表示现在执行的哪一种指令</p>
<p>Fi是目的寄存器</p>
<p>Fj，Fk是源寄存器</p>
<p>Qj，Qk在确定源寄存器中没有准备好的后，表明源寄存器的值要从哪一个单元的目的寄存器中得到。</p>
<p>Rj，Rk标志Fj，Fk是否就绪，是否已经被使用</p>
</blockquote>
<p><img src="/2023/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%AE%B0%E5%88%86%E7%89%8CScoreBoard/%E8%AE%B0%E5%88%86%E7%89%8C%E5%AD%98%E5%82%A8%E7%9A%84%E4%BF%A1%E6%81%AF-%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%9C%E7%8A%B6%E6%80%81.jpg"></p>
<p>上图是记分牌存储的信息-寄存器结果状态，专门用于记录哪个寄存器要作为某功能部件的目的寄存器。如图：F4就要作为MULT部件的目的寄存器</p>
<h2 id="2、工作流程解读"><a href="#2、工作流程解读" class="headerlink" title="2、工作流程解读"></a>2、工作流程解读</h2><p>在用记分牌实现乱序执行的处理器中（这里特指 CDC 6600 处理器了），<strong>一条指令分四个阶段执行</strong>，分别是<strong>发射、读数、执行、写回</strong>。本节会逐阶段解读工作过程。</p>
<p><img src="/2023/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%AE%B0%E5%88%86%E7%89%8CScoreBoard/%E8%AE%B0%E5%88%86%E7%89%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F.jpg"></p>
<p>对示意图做一点补充，<strong>黄色方框表示流水段寄存器</strong>，分别有指令寄存器、部件寄存器（即 MUL_1 这一列）、操作数寄存器（ OPRAND ）、结果寄存器（ RESULT ）。<strong>蓝色部分是解码单元和运算单元。红色部分是寄存器堆。绿色部分是记分牌</strong>。解码单元和记分牌的交互是指解码单元要“问”记分牌当前指令是否有“ WAW 冒险”和“ Structure 结构冒险”，如果没有，指令就可以顺利渡过当前的阶段，后面的 RAW、WAR 也都是这个意思。</p>
<h3 id="ID段"><a href="#ID段" class="headerlink" title="ID段"></a>ID段</h3><p>流水线ID段被分为两级</p>
<blockquote>
<p>流出-解析指令，检查结构相关</p>
<p>读操作数一直到不存在数据相关时，才读取操作数</p>
</blockquote>
<p>如果存在WAR或者WRW相关，记分牌会暂时暂停该指令的执行，知道相关消除后才继续执行</p>
<h4 id="流出-Issue"><a href="#流出-Issue" class="headerlink" title="流出(Issue)"></a>流出(Issue)</h4><p>1.本指令所需要的功能部件有空闲</p>
<p>2.正在执行指令使用的目的寄存器与本指令不同</p>
<blockquote>
<p>保证WAW相关</p>
</blockquote>
<h4 id="读操作数-Read-operands"><a href="#读操作数-Read-operands" class="headerlink" title="读操作数(Read operands)"></a>读操作数(Read operands)</h4><p>1.前面已经流出的还在运行的指令不对本指令的源操作数寄存器进行写操作</p>
<p>2.一个正在工作的功能部件已经完成了对这个寄存器的写操作</p>
<p>3.动态解决RAW相关</p>
<p><strong>前面两步完成原来ID段的功能</strong></p>
<h4 id="执行-Execution"><a href="#执行-Execution" class="headerlink" title="执行(Execution)"></a>执行(Execution)</h4><p>1.开始于取到操作数后</p>
<p>2.当结果产生后，修改记分牌</p>
<p>3.FP流水部件会占用多个周期</p>
<h4 id="写结果-Write-result"><a href="#写结果-Write-result" class="headerlink" title="写结果(Write result)"></a>写结果(Write result)</h4><p>检查WAR相关</p>
<h4 id="出现以下情况时，不允许指令写结果："><a href="#出现以下情况时，不允许指令写结果：" class="headerlink" title="出现以下情况时，不允许指令写结果："></a>出现以下情况时，不允许指令写结果：</h4><p>1.前面的某条指令没有读取操作数</p>
<p>2.其中的某个源操作数寄存器与本指令的目的寄存器相同</p>
<h2 id="记分牌的优缺点"><a href="#记分牌的优缺点" class="headerlink" title="记分牌的优缺点"></a>记分牌的优缺点</h2><p>记分牌算法是 CDC 公司提出的一个优秀的乱序执行算法，不过记分牌本身还是有一些不小的缺点，所以在 IBM 提出 Tomasulo 算法之后，业界普遍更青睐 Tomasulo 算法。</p>
<p>记分牌算法的优点是<strong>实现了指令的乱序执行，解决了乱序执行过程中的数据冒险问题</strong>，实现了指令的数据流式运行（即数据一旦准备好就开始运行，这区别于传统五级流水线中控制运行方式），并且实现起来并不复杂。</p>
<p>但是记分牌算法还是会因为 WAR 和 WAW 冒险而产生阻塞，<strong>且一旦产生阻塞，后续相同类型的指令就没办法继续发射</strong>（在乱序执行过程中，记分牌规定每一条配置路线都只能同时存在一条指令），即图中所列的“ Limited waiting space at functional units ”，如果后续相同类型的指令没法发射，那么更后面的也许可以立马执行的指令也会被阻塞到，这对性能有很大的影响。</p>
<p>而且记分牌算法在指令完成时不是顺序的（即写回的时候不按顺序），<strong>不按顺序完成指令会对程序的调试提出挑战</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>记分牌算法由 CDC 公司在上个世纪六十年代提出，是一个实现方式简单的乱序执行算法，应用多配置流水和记分牌算法，就可以实现一个乱序执行的处理器。但是记分牌又有一些缺点，这些缺点给了 IBM 提出的 Tomasulo 算法后来居上的机会。随着学习的深入，我后面会继续更新 Tomasulo 算法的原理和算法流程。</p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>指令的动态调度</tag>
      </tags>
  </entry>
  <entry>
    <title>哥们的第一篇博客</title>
    <url>/2023/05/24/%E5%93%A5%E4%BB%AC%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2-%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h1><p>其实我开始博客的时间已经相当晚了，现在已经是大三的下学期即将画上句号，按理说能学得都已经学完了，现在正是把学到的东西实践的时刻了。可惜我学艺不精，所以决定考研这条路，也就意味着我的专业课知识得从头来过，不过这也没什么好后悔的，正好以这为教训，引以为鉴。</p>
<blockquote>
<p>种一棵树最好的时间是十年前，其次是现在。</p>
</blockquote>
<p>准备搭建博客的目的也是为此，决定将我学到的东西分享到网上，正好督促我自己的学习进度，并且这种文书工作我也并不讨厌，可以说得上相得益彰了。总之，学习的路很长，漫漫长路从脚下开始。从今天开始我会将一些学习笔记、不那么隐私的生活感悟写进我的博客，如果你看到了，请付之一笑，这些只不过是我年少的妄语，随着时间的推移，身份的改变，我自己肯定也会改变的，再回过头来看说不定也觉得现在的自己年轻幼稚。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/05/23/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
