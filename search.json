[{"title":"测试stellar","path":"/2023/07/15/测试stellar/","content":"第一步：打开 GitHub打开 Stellar 的 GitHub 页面。第二步：点击 Star如果发现右上角的 Star 还没点亮，就点亮它！"},{"title":"树","path":"/2023/07/14/树/","content":"树树的遍历前序遍历void Inorder(int rt) &#123; if(nodeArray[rt].element()!=&#39;#&#39;) &#123; Inorder(nodeArray[rt].left()); cout&lt;&lt;nodeArray[rt].element()&lt;&lt;&quot; &quot;; Inorder(nodeArray[rt].right()); &#125; &#125; 中序遍历void Inorder(int rt) &#123; if(nodeArray[rt].element()!=&#39;#&#39;) &#123; Inorder(nodeArray[rt].left()); cout&lt;&lt;nodeArray[rt].element()&lt;&lt;&quot; &quot;; Inorder(nodeArray[rt].right()); &#125; &#125; 后序遍历void postorder(int rt) &#123; if(nodeArray[rt].element()!=&#39;#&#39;) &#123; postorder(nodeArray[rt].left()); postorder(nodeArray[rt].right()); cout&lt;&lt;nodeArray[rt].element()&lt;&lt;&quot; &quot;; &#125; &#125; 层次遍历void LevelOrderTraverse(int rt) &#123; queue&lt;int&gt; q; if(nodeArray[rt].element()!=&#39;#&#39;) q.push(rt); int temp; while(!q.empty()) &#123; temp=q.front(); cout&lt;&lt;nodeArray[temp].element()&lt;&lt;&quot; &quot;; q.pop(); int l=nodeArray[temp].left(); int r=nodeArray[temp].right(); //左右孩子不为空时则依次进入队列 if(nodeArray[l].element()!=&#39;#&#39;) q.push(l); if(nodeArray[r].element()!=&#39;#&#39;) q.push(r); &#125; &#125; 层次遍历可以用队列来实现，先将根节点放入队列中，然后弹出，同时将子节点放入队列，这样一直循环一直到队列为空为止。 记得当时上人工智能的时候就用到了队列，好像是A*算法吧，虽然不是树的结构，是图的结构，但也大同小异。","tags":["树"],"categories":["数据结构"]},{"title":"栈与队列","path":"/2023/07/14/栈与队列/","content":"栈前言栈是只允许在一段进行插入和删除操作的特殊的线性表。上课时老师把栈类比为弹匣，子弹被压进弹匣，不能从另一端出来，所以后面放进来的反而能先出，正所谓”后来居上”。 栈的基本操作大同小异，基本如下： 1.初始化一个空栈 2.判断栈是否为空 3.将一个元素入栈：记得检查是否栈满,链栈不必检查 4.将一个元素出栈：记得检查是否栈空 5.返回栈顶的值 6.销毁栈，释放空间 顺序栈顺序栈顾名思义，就是用顺序结构实现的栈，其主要特点和顺序表一致，需要划一片连续的存储空间来进行存储，基本上通过数组实现。 栈的顺序存储类型可描述为： typedef struct &#123; int data[MaxSize]; // 创建栈的空间，用数组表示 int top; // 用于表示栈顶元素的在数组中的位置 &#125;SqStack; top可以设置为-1也可以设置为0，这个每个题目不同视情况而定。 但顺序栈的缺点和顺序表一样，空间大小是固定死的，不能随机应变，而且还要连续的存储空间，有时候不易实现。 顺序栈中为了更加有效利用存储空间，提出共享栈，让两个顺序栈共享一个一维数组空间，两个栈的空间相互调节，通过两个栈顶指针相减为1判断栈满，减少存储空间，降低发生上溢的可能。 链栈链栈也很明显，采用了链式存储结构，优点在于便于多个栈共享存储空间和提高其效率，并且不会存在栈满上溢的情况。所有的操作都是在单链表的表头进行。 队列的基本操作如下： 1.初始化队列 2.判断队列是否为空 3.入队，要检查队列是否满了 4.出队，要检查队列是否为空 5.读队头元素。 队列前言队列和栈一样，也是受到限制的线性表，他只能在一端输出一端输入，和我们平时的排队很像，不允许插队，也不能中途离队，只能从队尾开始排，从队头出。 顺序队列顺序队列还是一样还是顺序结构，分配一块连续的存储空间存放队列的元素，并附设两个指针：队头指针和队尾指针。 队列的顺序存储类型可描述为： #define MaxSize 10 typedef struct &#123; int data[MaxSize];// 用于存放队列元素 int front, rear;// 用于存放队头和队尾指针，分别指向队头元素在队列数组中的位置和队尾元素的下一个位置 &#125;SqQueue; 队尾指针指向的位置也是可以变动的，视情况而定。 但是顺序队列有他的局限性，那就是判断队列是否满了不好判断，举个例子： 先将队列填满，那么rear队尾指针就已经到了maxsize-1，但是这时队头出去一个，那么这个队列就空出了一个，那么这个队列就没有满，但是rear的指针是不变的，所以并不能通过rear指针的位置判断队列是否满。 循环队列刚才说了顺序队列的缺陷，现在顺势引出循环队列，循环队列可以将其看作是一个环状的图形，将存储队列的元素从逻辑上看作是一个环，称为循环队列。但是当rear指针指到maxsize-1时，下一个就要到位置为0的地方，所以得到的结果应该通过取余数的方式实现 **%**。 那么循环队列判断队空和队满的条件是什么？显然队空的条件是Q.front&#x3D;&#x3D;Q.rear。若入队元素的速度快于出队元素的速度，那队尾指针很快就会赶上队首指针，到时候队满的条件也成了 Q.front&#x3D;&#x3D;Q.rear。以下有三种方法解决： 1.空出一个单元不存储数据，这样的话入队就少了一个队列单元，这种做法比较普遍。那么队头指针在队尾指针的下一个位置是队满的标志。 队满条件：(Q.rear+1)%MaxSize&#x3D;&#x3D;Q.front. 队空条件：Q.front&#x3D;&#x3D;Q.rear. 队列中元素的个数：(Q.rear-Q.front+MaxSize)%MaxSize. 2.类型增设表示元素个数的数据成员size。 队满条件：Q.size&#x3D;MaxSize。 队空条件：Q.Size&#x3D;0. 3.类型中设置tag数据成员，以区分队空还是队满。tag&#x3D;0时，就表示上一个操作为删除，如果Q.front&#x3D;&#x3D;Q.rear，那就是队空；tag&#x3D;1时，表示上一个操作为插入，如果Q.front&#x3D;&#x3D;Q.rear，就表示队满。 链式队列双端队列","tags":["栈,队列,数据结构"],"categories":["数据结构"]},{"title":"实习游记","path":"/2023/07/03/实习游记/","content":"第一天21点出发长沙火车站，我几乎没有坐过绿皮火车，唯有的记忆就是初一的时候从厦门往来坐了次卧铺，感觉空间还行，和朋友们打牌看书就欢快的度过了一天一夜。并没有感受到采访时经常提到的人们乘坐绿皮火车回家的辛苦。 那次的厦门之行其实没有太多值得回忆的地方，可能是因为那时候还很小，又或者景观虽然美丽但是却没有太多的感触，可能身边的朋友比美景更重要。记忆比较深刻的大概是和mhy和zjy跑到厦门大学的书店买了纪念品和几本书——《洗脑》《反洗脑》《死神永生》，前面两本书后来被我捐到初中的图书馆里面了。 从地铁站出来，引入眼帘的就是宏伟壮观的长沙火车站，火车站就伫立在一大块平地上，附近伴生的建筑也为数众多，火车站这三个大字就位于建筑的顶上，火红的标字提醒着附近的人们这里是哪里。来往的人们也络绎不绝，大多数都是来往的旅客，其中还夹杂着几个为生活谋生的人，他们挥舞着手中的商品来进行推销，却总是遭到人们的拒绝。走进候车站，人山人海，大家都席地而坐等待候车，更有甚者甚至连地铺都打好了。 等啊等终于车到了，我们提着行李箱一路奔驰到车门处，学校给我们订的票是硬座，一走进去就惊到了，中间的道路十分的狭窄，能通过行李箱就已经是极限了，然后座位也是非常的狭窄，我的那个位置要坐下3个人，但是只有最里面才有小桌子，也没有充电的地方，由于我没有充电宝所以只能节省用电，掏出了我新买的《地铁》小说开始看，其实车里面的灯也是属于不是很亮的类型，散发出淡淡的黄光，就像我现在住的酒店的灯光，不是很适合读书。看了一会就感觉到了疲倦，于是闭目养神。没有桌子的依靠不方便睡眠，所以只能小憩一会就醒来继续看书。就这样半睡半醒的度过了那一段时间，终于天亮了，天亮得很早，5点出头就已经白昼，路上的美景也有不少，印象最深刻的就是广阔的农田，因为地势的平坦所以很多土地连在一起做的农田，青青的麦子在风中摇曳，给人一种”勃勃生机，万物竟发”的景象(笑)，还有就是火车在行进路上时不时就发出鸣笛的声音，悠长而尖锐，然后就看到身着工作服的火车工人们在旁边默默的等待火车的通过，感谢他们，到了白天找刘杰接了充电宝，然后开始看起了大决战系列的电影解说，时间就这样悄然过去，直到到达目的地。 到了杭州，还没出去，只是中途在大巴上看到的景象，感觉杭州和长沙并无太大区别，都是耸立的建筑群，然后是熙熙往来的人们。也好似我在写这篇游记时的酒店周旁，正响着耳熟能详的广场舞音乐，让我感觉好像回到了小学，我坐在自己的书房看书的时候就是广场舞音乐伴随着我。看起来所有城市都一样，有着共通性。但是我认为每个城市都有着属于自己的精神底色，这是时代、历史、文化所赋予给人们的。而要看到这一点，那就等自由时间出去游玩再去探索吧。 今天就到这里，因为火车上实在是疲惫，睡午觉的时候一不小心睡过了头，甚至还影响了晚上的身体，所以今天自由活动就没有出去 第二天大清早一起来就发现已经7点半了，赶紧准备好行李就下楼吃早饭，发现睡觉还是睡得太晚了，7点多起来居然还是带着一丝困意，早餐还算丰盛，有手抓饭、包子馒头、烧麦、豆浆等等，匆匆吃了点就下楼准备上车。 上车后观察沿途的风景，我发现杭州的绿化做的很好，到处都处在绿荫之下，每隔3步就是一棵树，放眼望去一片绿意，让人心旷神怡。而且也能明显的看出杭州对这次延迟的亚运会的重视，到处都贴满了相关的标语和吉祥物–三个类似于当年奥运会的福娃一样的小人，甚至连杭州本地的企业也是相当的配合政府的宣传工作，在给我们的ppt上都有着亚运相关的标识。 上午我们去的是海康威视，不查不知道，海康威视居然是全球安防市场的龙头企业，是我孤陋寡闻了(😀)，先是去的3期区，去看了相关的展会，走进去体验了很多很有意思的科技，只是可惜因为保密的缘故没有拍照。 看得出，很多相关技术都是与感知有关的技术，其中最主要的还是基于视觉的感知吧，后来跟我们分享的主管人也是这么说的，一开始就是靠着监控发的家。应该是后面再一步步拓展扩大了业务范围，有了新的理念–安防。这种东西可以和政府形成密切的商业关系，后面也证实了我的看法，与政府的合作业务占比五分之一。只能说怪不得学校开设了计算机视觉和人工智能这两门课，足以证明这可能是未来的主流方向，不过被封锁的道路会走的相当的艰难。 然后就到了四期区的会议厅听报告，几位给我们宣讲的学长很有意思，两位都很腼腆，其中一位学长说的话也很有道理，就是如果你真的下定决心去做一件事，那么一年的时间足以，这次实习游玩结束之后我也当定下自己的考研决心，收心学习了。海康威视的人才培养方案看起来也相当的可以，不管是从技术层面还是管理层面都很不错，而且正常的福利薪资都很不错。 听完会议厅就上4楼去食堂就餐，食堂的饭菜很多种多样，我点了粉蒸肉、口水鸡、蒸蛋、瓦罐煨汤，结果也没花很多钱，感觉比学校强(乐)，不过仔细品尝还是和外面的饭店不能比，尝起来味道还不够到位。 吃完饭就打道回府了，但是来杭州不去西湖就等于白来，于是在我们的强烈要求下，田泽安老师主动帮我们询问最后把我们丢到地铁站的门口，西湖之旅就这样拉开帷幕。杭州的地铁站的空间感觉比长沙要大，但是人并不算很多，而且检查也比较的放松，只扫描一下包就放行了。车费也比长沙要贵，做一段路程就有将近10元的车费，不过我们也坐了很长的一段距离就对了,杭州应该比长沙还要大很多。 从断桥残雪开始一直走到雷峰塔，从中午一直走到了晚上，感觉西湖并没有想象中的那样充满人文关怀和历史味，更多的反而是自然风光，西湖边上最多的是游客而不是本地人，或者说本地的文化没有体现得出来，感觉还是得去集市或者书店这样的地方可能在人与人之间的交流上才会体现出来吧。最后走的腿都软了，西湖感觉作为一个本地锻炼休息的公园比较的合适，至于其他的就感觉商业气息比较浓重了。 希望后面能够有机会去一趟书店，听说这里的书店很富有古代的气息，而且有很多古籍。并且还想要一个自己的私有的印章。 第三天上午阴雨连绵，然后坐车坐了很久，长途非常犯困，就在路上一路睡了过去，不过在睡前也看了看杭州的风景，在途经山体的时候注意到了山上面虽然郁郁葱葱，但是山体的侧面露出的岩石光秃秃的，到处都是被腐蚀的痕迹，有的山体甚至还铺上了一层网络，没有什么植物生长在上面而且还是垂直的，感觉山体滑坡的风险还是不小的。 最后到了今天要参观的企业，不过感觉不如昨天的海康，官腔味比较的浓，科研的顶尖成果没怎么看到，感觉传统工业要大于高新科技，不过看得到党建做的还是可以，应该是属于中流砥柱类型的工业集团吧，与人们的日常生活密切相关。 然后吃过盒饭就继续坐车回去了，但是由于下雨的缘故(下午没下雨了，我不知道&#x2F;(ㄒoㄒ)&#x2F;~~)，所以在房间里玩了一天的游戏。 第四天今天是在杭州的最后一天，也是最有意义的一天。 上午很早就起来，把东西都收拾好确认没有遗漏后就离开了酒店，上午还是有一点小雨的，今天来到了与第二天的人工智能小镇在一块地的之江实验室。这下可真的是国家级别的实验室了，产出的成果非常丰富，而且有很多的专利和论文都在世界的前列，可惜和海康一样禁止拍照，值得一提的是原来之江实验室和湖大有合作，看来湖大在编译领域还是颇有建树的，后面还搞了个签约仪式，可惜学生去不了。然后报告也是面向博士后的报告，基本上都是成果和成员方面的，为科研配套的建筑都在建筑之中，相当的可以。可惜的就是不管饭，这一点差评(😀)！ 下午放完行李就是自由活动时间，因为第三天没出去，所以最后一段时间肯定要好好利用，根据旅游手册上面的描写，河坊街有很多的纪念品和当地特产可以购买，所以我坐这地铁坐到江城路再转到吴山广场来到了河坊街，果然时古色古香的建筑。 先来到了一条古玩街，这一条街上都是在售卖小手工艺品，店面很小，仅仅只能坐进一个人，掀开帷幕进去，就可以感到丝丝凉意，然人惬意。但是这条街开的店面不多，只有一半不到的店面开着，我在其中寻找印章店，还真给我找到了，但是老板居然不在，仅留下商品在这里，等待片刻，原来老板就在街边上乘凉。只见老板在左下角打开一个小木板，露出一个小洞，然后老板就自己费劲的钻了进去，很是辛苦。然后就跟老板谈好了价钱，搞定了印章。接着买了点龙井给家里人之后，我直奔中山中路，想一观书房的模样。 穿过了一段古建筑群后来到了书房面前，书房不大，但是边上并无建筑，反而很空旷，书房用围栏给围起来，不同于其他的建筑，书房看起来是木头搭起来的，看起来更具韵味。走进书房，就看到很多小玩意摆在边上，很多是古代南宋时期的一些作品的介绍，还有一些瓷器和木器的小玩意，别具匠心，穿过了一段狭窄的道路，终于来到了空旷的房间，说是空旷，但是平地上并不空旷，摆满了各种纪念品的小玩意供来往的人们观赏和购买。真正空旷的地方反而是阶梯，阶梯很长，并且在阶梯两边设立了坐枕，大家都坐在两边，有的人戴上耳机，然后津津有味的阅读手上的书籍；有的人把鞋一脱，然后把手和脚搭在冰凉的木头上，享受着这炎热的夏日难得的凉爽，还有小孩躺在木板上，将头放在母亲的腿上，深深的睡了过去，神情喜悦。但是这里环境主要还是安静，不管什么样的人，来到这处地方都会安静下来，不想惊扰什么似的。来都来了，总得挑一本书去吧，然后我就看了看相关的书籍，书架很高，基本上只有前三层可以看到，再往上就是人们够不到也看不到的地方了，但是上面也摆放满了书籍，让人禁不住好奇上面难道是什么禁书吗。再来看书的种类，种类还是比较的丰富，很多都是历史、文化、艺术方面的书，但是都并不有名，大多小众，而且一个种类也就三排，图书量也不大。并且并不像旅游指南上面所的那样大多为南宋时期的作品或是描述南宋文化的作品。最后我挑来选去，选择了孟德斯鸠的《论法的精神》，久仰大名，希望能好好阅读。之后就打道回府了。 感觉南宋书房不愧书房之名吧，感觉比起单纯的卖书，反而更注重一种氛围，希望人们能够在这样的安静环境下仔细阅读，卖的什么书反而不是很重要，就像是主题店一样。 然后就踏上了回家的步伐，杭州之旅就这样结束了。 最后我们还是硬座回去，但是与之前不同，这次显得更加的拥挤，站票的人们挤作一团，蜷缩在狭窄的过道上，大部分人都在没有空调的出口那里挤着，十分的困难，更重要的是我们定的晚上的票，所以他们不得不考虑站着睡觉。有的人甚至还看上了我露出来的一点点座位的缝隙，将屁股移到那里只为了让自己能轻松一点。最后实在不好意思就席地而坐然后双手抱着膝盖这样睡觉，还要被时不时路过上厕所的人叫醒。甚至还有人2点多了还要跑到出口那里去抽烟，我也是醉了(😶)。在门口的那个胖哥们甚至站着都睡着了，还发出了很大的鼾声，姿势也很搞笑，一只手竖着搭载门沿上，身体靠在这只手的位置，另一只手垂直于门沿，手掌搭在另一个门沿上，形成了一个“直角”的姿势，不过也很辛酸的，看起来实在是太辛苦了，而且这样也没有办法睡太死，稍有动静就醒来了，那个兄弟就只能费劲的张开半只眼来观察周围的动静，然后又很快的睡着很快的醒来，周而复始。我这次还是没有分到有桌子的那一侧，所以我只好坐正了睡觉，但是每睡不了半小时就被脖子的酸痛所“叫醒”，实在没办法睡了，根本睡不着，但是又很困，睡不着就玩玩手机，然后不知不觉进入睡眠等待下一次的醒来。于是在这种半梦半醒的状态下迎来了天亮，“相与枕藉乎舟中，不知东方之既白”。","tags":["游记"],"categories":["游记"]},{"title":"最近的一些烦恼或者想法","path":"/2023/07/01/最近的一些烦恼或者想法/","content":"最近看了很多的关于解放战争的视频，深感现在中国的不易。但是又同时看到了地方债的问题，产业转型升级的困难和许多地方政府出现的问题，比如青海湖要围起来。每当看到底下的评论区阴阳怪气时总是颇感难受，但是基于实事求是的原则来说，这些中很多都是事实，不能因为别人的过度放大而忽视。我们是“幸运”的一代，生长于经济增长的大环境中，但是在即将登上历史舞台的时候遇到了疫情，从而经济下行，就业困难。有时候总在想，一代人有一代人的使命，或许我们这一代人的使命就是带领中国走出现在的困境迈出下一步，但是又深感无力，因为自己的力量微薄并且不算努力，能力有限，就只能干着急。 我和我爸其实也讨论过现在的困难处境，但是我爸也告诉我说这些事情有必要了解，因为大环境的改变会影响所有人，但是又不可过度关注，因为自己改变不了这个世界，我只能先改变自己，先把自己的事情做好，再来改变世界。过去人们的艰苦奋斗造就了现在中国人的辉煌，我就不信现在还能比过去更加的困难吗。雄关漫道真如铁，而今迈步从头越。在前人的基础上迈出属于自己的一步吧。"},{"title":"数组和链表","path":"/2023/06/14/数组和链表/","content":"基础知识-数组与链表数组数组是被操作系统分配的一个内存块，用来保存数组的元素。通过使用特定元素的索引作为数组下标，可以在常数时间内访问数组元素。 数组的优点 简单且易用 访问元素快(常数时间) 数组的缺点 大小固定：数组的大小是静态的（要在使用前指定数组的大小） 分配一个块：数组初始化分配空间时，有时不可能分配能存储整个数组的内存（如果数组的大小太大） 基于位置的插入操作实现复杂 链表链表是一种用于存储数据集合的数据结构。链表中相邻连续元素之间通过指针链接，最后一个元素的后继指针的值为NULL。 链表的优点 链表可以在常数时间拓展 在程序执行过程中，链表的大小可以增长或减小 链表的空间能够按需分配 没有内存空间的浪费 链表的缺点 链表的主要缺点在于访问单个元素的时间开销问题 存储空间的离散性降低了元素的存储效率 链表中的指针需要额外的内存开销 物理实现 补充-7.1顺序表的实现就是用数组完成的，优势就在于访问数据的时候直接根据下标就可以快速寻找，而链表不行，只能回归表头再顺序执行，消耗的时间比较长。但是再增删数据的情况下，数组就明显不如链表，数组必须移动增删的数据后面的数据，而链表只需要把数据域后面的指针改一下指向的方向就可以了。","tags":["线性表"],"categories":["数据结构"]},{"title":"6月份学习计划","path":"/2023/06/13/6月份学习计划/","content":"现在是6月13日，已经距离期末考试的结束有过一段时间了，而且休息也休息过了，接下来就是彻底投入到考研的准备。因为避免期末不挂科，所以用了半个多月的时间一直在复习，已经很久没有碰过考研的学习了，数学和英语都有点忘却。因为首先17日要考六级，所以这几天还是以英语的复习为主，过几天再重新开始数学的复习，而且这次考试又把我分到财院校区去了，这下又得提前踩好点。另外就是18日要开始小学期了，这次小学期我选择的是数据库相关的知识，可以提前学习。 6月还剩下半个月，我得把数学第二轮尽快搞完，因为还有线代没学，并且政治8、9月份的时候要开始了，后面就不会分到数学太多的时间，所以得尽快完成数学的深入学习。 另外就是英语，很久没有搞了，得重新将英语的学习回归日常，另外现在可以多做一些原题了，计划是每周做2篇阅读题。 数据结构的学习还是想放到下一个月，7月份已经放暑假了，希望能够留校，这样就可以在图书馆里学习，家里确实不适合学习，也没有免费的空调蹭。","categories":["计划"]},{"title":"基本流水线","path":"/2023/06/06/基本流水线/","content":"基本流水线流水线的基本概念一个任务可以分解成为k个子任务 k个子任务在k个不同阶段(使用不同的资源)运行 每个子任务执行需要1个单位时间 整个任务的执行时间为k倍单位时间 流水线执行模式是重叠执行模式 k个流水段，并行执行k个不同任务 每个单位时间，一个任务进入&#x2F;离开流水线 同步流水线 流水段之间采用时钟控制的寄存器文件 时钟上升沿到达时… -所有寄存器同时保存前一流水段的结果 流水段是组合逻辑电路 流水线设计中希望各段相对平衡 流水线的性能• 设 τi&#x3D;time delay in stage Si • 时钟周期 τ &#x3D;max(τi) 为最长的流水段延迟 • 时钟频率 f &#x3D; 1&#x2F;τ &#x3D; 1&#x2F;max(τi) • 流水线可以在k+n-1个时钟周期内完成n个任务 – 完成第一个任务需要 k个时钟周期 – 其他n-1个任务，在后续的n-1个时钟周期完成 • K-段流水线的理想加速比（相对于串行执行） 典型的RISC 5段指令流水 五个流水段，每段的延迟为1个cycle IF：取指阶段 -选择地址：下一条指令地址、转移地址 ID：译码阶段 -确定控制信号并从寄存器文件中读取寄存器值 EX：执行 -Load&#x2F;Store:计算有效地址 -Branch：计算转移地址并确定转移方向 MEM：存储器访问(仅Load和Store) WB：结果写回 流水线的可视化表示多条指令执行多个时钟周期 指令按程序从上到下排序 图中展示了每一时钟周期资源的使用情况 不同指令相邻阶段之间没有干扰 指令流时序时序图展示： 每个时钟周期指令所使用的流水段情况 指令流在采用5段流水线执行模式的执行情况","tags":["流水线"],"categories":["计算机体系结构"]},{"title":"机器学习","path":"/2023/06/01/机器学习/","content":"学习概述机器学习机器可以自动”学习”的算法，即从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。 学习的反馈类型无监督学习不提供任何的显示反馈，比如：KNN聚类算法 监督学习提供“输入-输出”对，学习从输入到输出的映射函数。比如：贝叶斯网络，人工神经网络，决策树 半监督学习提供少量的“输入-输出”对，大部分样本未标注。基于图的学习算法。 监督学习监督学习的任务是：1.给定由N个“输入-输出”对样例组成的训练集从给定的训练数据集中学习出一个函数（模型参数） 2.当新的数据到来时，可以根据这个函数预测结果 分类与回归分类问题的主要目的是预测分类标签，标签来自预定义的可选列表。分类问题可分为二分类和多分类。 比如邮件系统，对于垃圾邮件的识别就是一个分类问题。 回归任务的目标是预测一个连续值。 例如，根据教育水平、年龄和居住地来预测一个人的年收入，预测的结果是一个金额数值。 K-折交叉验证思想：每个样本既作为训练数据，又作为测试数据 将数据分成k个相等的子集 执行k轮次学习，每一轮1&#x2F;k个数据作为测试数据，其他作为训练数据 精度增加伴随着代价增加 过拟合&#x2F;欠拟合过拟合拟合模型时，过分关注训练集的细节，训练集学习得到的目标函数在训练集上性能很好，在测试集上性能不高。 训练出的模型太复杂，不能泛化到新数据上的模型就叫做过拟合。 其实就是训练次数过多导致找到了太多只适用于训练集的特征，过于细化所以不能通用。 欠拟合相反，如果模型过于简单，那么就可能无法抓住数据的全部内容以及数据中的变化。甚至可能模型在训练集上的表现也很差。也就是没要找到特征。 如何避免过拟合 Early stopping （适当的stoppingcriterion）: Early stopping便是一种迭代次数截断的方法来防止过拟 合的方法，即在模型对训练数据集迭代收敛之前停止迭代 来防止过拟合 2) 数据集扩增 : 数据机扩增即需要得到更多的符合要求 的数据，即和已有的数据是独立同分布的，或者近似独立 同分布的。一般方法有：从数据源头采集更多数据，复制 原有数据并加上随机噪声，重采样，根据当前数据集估计 数据分布参数，使用该分布产生更多数据等 3）正则化方法：一般有L1正则与L2正则等 4）Dropout：正则是通过在代价函数后面加上正则项来防 止模型过拟合的。而在神经网络中，有一种方法是通过修 改神经网络本身结构来实现的，其名为Dropout。 信息理论：熵熵H(x)：衡量数据集的纯度 熵曲线 两个样本(P,N),p个正样本数，n个负样本数，p&#x3D;9,n&#x3D;5 信息理论：属性选择根据熵的定义，公平掷硬币的熵： $$H(Fair)&#x3D;− (0.5log_2⁡0.5 +0.5 log_2⁡0.5 )&#x3D; 1$$ 如果加载硬币，使之能掷出99%正面向上，则有 $$H(Loaded)&#x3D;− (0.99log_2⁡0.99+0. 01log_2⁡0.01) ≈0.08$$ 设布尔变量以q的概率为真，则可定义该变量的熵为： $$B(q)&#x3D;− (q log_2⁡q +(1-q)log_2⁡(1-q) )$$ 因此 $$H(Loaded)&#x3D;B(0.99)≈0.08$$ 一个训练数据集包含p个正样本,n个负样本，则目标属性在整个样例集上的熵为： $$H(Goal)&#x3D; B(𝑝&#x2F;(𝑝+𝑛))$$ 一个属性A的取值为A1,A2,…,Av,根据属性A的取值将训练数据集E分成E1,E2,…Ev,每个子集Ei有pi个正例和ni个反例，则选择属性A后，剩余的期望熵值为： 属性A的信息收益是熵的期望减少，即原有的熵值-属性A分裂后的熵值： $$Gain(A)&#x3D; B(𝑝&#x2F;(𝑝+𝑛)) - H(A)$$ $$Gain(Patrons)&#x3D; 1−[2&#x2F;12B(0&#x2F;2)+4&#x2F;12B(4&#x2F;4)+6&#x2F;12B(2&#x2F;6)]≈0.541 $$ $$Gain(Type)&#x3D; 1−[2&#x2F;12B(1&#x2F;2)+2&#x2F;12B(1&#x2F;2)+4&#x2F;12B(2&#x2F;4)+4&#x2F;12B(2&#x2F;4)]&#x3D;0$$ $$Gain(Patrons)&gt;Gain(Type)$$ 选择信息收益最大的属性进行分裂 决策树剪枝找到过度拟合的结点，删除该节点及其分支 如果一个节点是过度拟合的，则该结点不同属性之下所含正样本的比例与整个集合的比例大致相同，pk&#x2F;(pk+nk)≈p&#x2F;(p+n)","categories":["人工智能"]},{"title":"朴素贝叶斯分类算法","path":"/2023/05/27/朴素贝叶斯分类算法/","content":"一、简介贝叶斯分类是一类分类算法的总称，算法以贝叶斯定理为基础，所以称为贝叶斯分类。本文将首先介绍分类问题，对分类问题进行一个正式的定义。然后，介绍贝叶斯分类算法的基础——贝叶斯定理。最后，通过实例讨论贝叶斯分类中最简单的一种：朴素贝叶斯分类。 二、分类问题介绍分类，顾名思义，就是把集合分出类别来，比如人类可以分为黄种人、白种人、黑种人。 在数学方面可以做如下定义： 已知集合： 和 确定映射规则 使得任意有 且仅有一个 使得 成立 其中C叫做类别集合，其中每一个元素是一个类别，而I叫做项集合，其中每一个元素是一个待分类项，f叫做分类器。分类算法的任务就是构造分类器f。 值得注意的是，分类问题常常采用经验性方法构造映射规则，及一般情况下的分类问题缺少足够的信息来构造百分百正确的映射规则，而是通过对经验数据的学习从而实现一定概率意义上的正确的分类，因此从训练出的分类器并不是一定能准确地将每个待分类项映射到其分类，分类器的质量与分类器构造方法、待分类数据的特性以及数据样本数量等诸多因素相关。 朴素贝叶斯算法前提说明朴素贝叶斯算法成立的前提：各属性之间相互独立。当数据集满足这种独立性假设时，分类的准确度较高，否则可能较低。 贝叶斯定理理论基础贝叶斯定理是关于随机事件（或边缘概率）的一则定理。这个定理解决了现实生活里经常遇到的问题：已知某条件概率，如何得到两个事件交换后的概率，也就是在已知P(A|B)的情况下如何求得P(B|A) 贝叶斯定理之所以有用，是因为我们在生活中经常遇到这种情况：我们可以很容易直接得出P(A|B)，P(B|A)则很难直接得出，但我们更关心P(B|A)，贝叶斯定理就为我们打通从P(A|B)获得P(B|A)的道路。 下面不加证明地直接给出贝叶斯定理： 朴素贝叶斯分类的原理和流程思想基础朴素贝叶斯的思想基础：对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，就认为此待分类项属于哪个类别。就比如说你在大街上见到一个黑哥们，你肯定首先认为他是个非洲人，但实际上黑人非洲、亚洲、美洲都有。但是非洲的黑人最多概率最大，所以你会认为他是个非洲人。 图示流程 正式定义1.设 为一个待分类项，而每个a为x的一个特征属性 2.有类别集合 3.计算 4.如果 那么x∈yk 现在的关键就是如何计算第三步的各个条件概率。可以这样做： 1、找到一个已知分类的待分类项集合，这个集合叫做训练样本集。 2、统计得到在各类别下各个特征属性的条件概率估计。即： 3、如果各个特征属性是条件独立的，则根据贝叶斯定理有如下推导： 因为分母对所有的类别为常数，因此我们将分子最大化即可。又因为各特征属性是条件独立的，所以有： 可以看到，整个朴素贝叶斯分类分为三个阶段： 第一阶段——准备工作阶段，这个阶段的任务是为朴素贝叶斯分类做必要的准备，主要工作是根据具体情况确定特征属性，并对每个特征属性进行适当划分，然后由人工对一部分待分类项进行分类，形成训练样本集合。这一阶段的输入是所有待分类数据，输出是特征属性和训练样本。这一阶段是整个朴素贝叶斯分类中唯一需要人工完成的阶段，其质量对整个过程将有重要影响，分类器的质量很大程度上由特征属性、特征属性划分及训练样本质量决定。 第二阶段——分类器训练阶段，这个阶段的任务就是生成分类器，主要工作是计算每个类别在训练样本中的出现频率及每个特征属性划分对每个类别的条件概率估计，并将结果记录。其输入是特征属性和训练样本，输出是分类器。这一阶段是机械性阶段，根据前面讨论的公式可以由程序自动计算完成。 第三阶段——应用阶段。这个阶段的任务是使用分类器对待分类项进行分类，其输入是分类器和待分类项，输出是待分类项与类别的映射关系。这一阶段也是机械性阶段，由程序完成。 特殊情况这一节讨论P(a|y)的估计。 由上文看出，计算各个划分的条件概率P(a|y)是朴素贝叶斯分类的关键性步骤，当特征属性为离散值时，只要很方便的统计训练样本中各个划分在每个类别中出现的频率即可用来估计P(a|y)，下面重点讨论特征属性是连续值的情况。 当特征属性为连续值时，通常假定其值服从高斯分布（也称正态分布）。即： 因此只要计算出训练样本中各个类别中此特征项划分的各均值和标准差，代入上述公式即可得到需要的估计值。均值与标准差的计算在此不再赘述。 另一个需要讨论的问题就是当P(a|y)&#x3D;0怎么办，当某个类别下某个特征项划分没有出现时，就是产生这种现象，这会令分类器质量大大降低。为了解决这个问题，我们引入Laplace校准，它的思想非常简单，就是对没类别下所有划分的计数加1，这样如果训练样本集数量充分大时，并不会对结果产生影响，并且解决了上述频率为0的尴尬局面。 实验：汽车估计数据集一．数据描述： n汽车评估数据集包含1728个数据，其中训练数据1350，测试数据 378个。每个数据包含6个属性，所有的数据分为4类： ClassValues: unacc, acc,good, vgood Attributes: buying: vhigh,high, med, low. maint: vhigh,high, med, low. doors:2, 3, 4, 5more. persons:2, 4, more. lug_boot:small, med, big. safety:low, med, high. 未校准： 校准后： 例题","tags":["贝叶斯算法"],"categories":["人工智能"]},{"title":"监听法和目录法","path":"/2023/05/27/监听法和目录法/","content":""},{"title":"计算机体系结构-Tomasulo算法","path":"/2023/05/26/计算机体系结构-Tomasulo算法/","content":"1.与记分牌算法的比较1.1 重新审视数据冒险假数据冒险影响了记分牌算法的乱序性能。 那么什么是假数据冒险呢？ 我们都知道，数据冒险有WAW,WAR,RAR,RAW这四种，而其中RAR其实在流水线中并没有影响指令的执行，所以可以把它忽略。 在剩下三个之中，只有RAW“写后读”才是真冒险，而WAR和WAW都是假冒险。为什么呢？因为这两种冒险都是在第一个操作后进行写操作，说明写操作的目标寄存器是被使用的状态，所以必须阻塞自己才能不引发冲突。而解决方法其实很简单，只要把写操作的目标寄存器改变成没有冲突的寄存器就可以解决。 但是RAW是无解的，因为后续指令读取的数据必须由前序指令算的，有明显的数据依赖，所以才是”真冒险” 这三种冒险的差别就出现在”数据依赖方面”。读后写”和“写后写”通过改写寄存器名字就可以消除冒险，这表明这两种冒险其实没有数据依赖，即发生冒险的指令之间其实没有数据流动。想要挖掘出指令的乱序潜力，理解这一点非常重要。 综上所述，“写后写”和“读后写”冒险不是真冒险，没必要为他们阻塞指令的流动 例子： 首先看“写后写”WAW冒险，可以看到第一条、第三条指令都要写R3寄存器，犯了“写后写”冒险。在记分牌中如果遇到这种情况，后序的AND指令因为和ADD指令发生“写后写”冒险，所以无法发射，流水线在发射阶段堵塞。 但是如果把AND指令的目的寄存器改写成R10，那么冒险就消除了，AND指令可以发射，只不过写回的目的寄存器是R10而不是R3。 同样的，审视“读后写”WAR冒险。第一条指令和第二条指令关于R3发生了“读后写”冒险，在记分牌中如果碰到这种情况，第二条指令在写回阶段时会检测到第一条指令需要读取R3旧值，所以第二条指令会卡在写回阶段，直到第一条指令读取完R3并且通知到自己为止。 如果把第二条指令的R3改写成R10，冒险就又解决了，第一条指令可以去读R3，第二条指令的更新结果存在R10，不会覆盖R3的旧值。 1.2 Tomasulo算法与记分牌记分牌存在巨大的缺点，每个运算部件只有一个译码信息流水段寄存器，这意味着多配置处理器中的每一条配置通路同一时间只能存在一条指令，如果某一配置通路被占据，那么后面所有的指令都要被阻塞。 而且记分牌为了乱序执行指令，在碰到写后写、读后写这两个冒险的时候也会暂停流水线（为什么这里不提写后读呢，见后文），而这其实是不必要的，因此记分牌算法还是没有最大限度地挖掘出指令的乱序潜力。而且记分牌的“写回”是乱序的，乱序完成指令不利于处理器处理中断、异常等情况，不利于程序员debug程序。 Tomasulo采用了许多记分牌中的理念 两个较大的差异 Tomasulo算法中，冲突检测和执行控制是分布的，利用保留站实现 Tomasulo算法不用检查WAR和WAW相关，已经使用算法本身消除掉了 寄存器重命名消除假数据相关的主要方法是寄存器重命名。 寄存器重命名其实就是修改寄存器的名字，防止寄存器冲突。那么就意味着需要在原来寄存器的基础上额外有寄存器。 实现额外寄存器的方法有两种 可以在逻辑寄存器（MIPS指令集规定了32个逻辑寄存器）之外额外有一组物理寄存器，结构如图。假如逻辑寄存器正要被改写或被读，就置Busy位为1，并通过Tag指示最新数据将被写到哪一个物理寄存器。通过这样的方法，我们可以在新数据计算完毕时立刻写回，同时也允许前序指令读取寄存器旧值（因为旧值没有被覆盖，它还存在于逻辑寄存器中）。 上面这种方法把逻辑寄存器和物理寄存器分离开，其实完全可以把两者混合起来，即为处理器提供超过逻辑寄存器数量的寄存器，如MIPS指令集要求32个逻辑寄存器，那就设计40个物理寄存器给处理器，至于哪些寄存器是ISA要求的32个寄存器，则视程序运行情况而定，相关信息可以用一个表格存储起来，理论上任何一个物理寄存器都可能是任何一个逻辑寄存器。 上面简单说明了两种寄存器重命名的方法，Tomasulo算法采用了第一种，但是不彻底，说Tomasulo算法蕴含寄存器重命名的思想则更合适。 2. Tomasulo算法2.1 Tomasulo算法产生的背景IBM 360&#x2F;91比CDC6600(记分牌算法)晚三年推出商业计算机使用cache技术之前 整个360系列仅一个指令系统和一个编译器要求具有很高的浮点性能，但不是通过高端机器的专用的编译器实现 只有四个双精度浮点寄存器，编译器调度的有效性受到很大限制 访存时间和浮点计算时间都很长 可支持循环的多次迭代重叠执行 2.2 Tomasulo算法的结构Tomasulo最大的特点就是通过借助重命名的思想消除了假数据冒险，从而提高了机器的乱序性能。 先看这个结构： 首先是FP OP Queue，这里是浮点指令队列，指令在这里等待发射； 青绿色模块是加法单元和乘法单元的保留站（保留站是什么？保留站保留已经发射的指令的信息和缓冲下来的数据。关于保留站，后文会有更多介绍）； 蓝绿色的Address Unit是地址计算单元，在这个算法中存储指令在执行前会先计算好存储地址； Memory Unit则是存储单元； CDB是数据广播总线，它可以直达寄存器堆（用来更新通用寄存器）、加法乘法存储单元的保留站（输送保留站中指令需要的数据）。 要解读Tomasulo算法，就要搞清楚这个算法运用了哪些信息来调度指令，然后要分清楚算法的调度步骤。接下来首先解释Tomasulo算法利用了哪些信息，然后讲解算法的调度步骤。 2.2.1 保留站和寄存器结果状态表保留站是Tomasulo算法的精髓，不同于记分牌每一个配置通路前面的译码信息流水段寄存器，记分牌中每一条配置通路只能存放一条指令，而Tomasulo算法则为每一条通路配置了一组缓冲。就像上图中的绿色模块，其中浮点加法单元拥有能够缓冲三条指令的保留站。保留站存储的信息和记分牌有点类似。 保留站的结构有点像cache，可能有多行数据，每一行都对应一条被发射到保留站的指令。保留站每一行都有Busy位，指示这一行是否现存有指令；Vj和Vk与记分牌不同，记分牌的Vj和Vk会记录源寄存器的编号，而保留站则直接把能读取的数据直接拷贝到保留站中，可想而知，一旦数据进入保留站，那对应的寄存器就和这条指令没瓜葛了；Qj和Qk的信息和记分牌一样，记录尚不能读取的数据将由哪条指令算出；A是存储指令的地址，用于存放立即数和计算得到的地址数据。 看上去保留站和记分牌非常相似，但是两者其实有很大的不同。以上图的Add为例，保留站中有三行Add信息，这三行数据对应的是同一个加法单元，而在记分牌中这代表着三个加法单元。记分牌那样的一条通路只对应一条信息的做法容易造成指令堵塞、无法发射，而保留站则为每条通路预留了缓冲区，指令可以在加法单元忙碌的时候发射到保留站的缓冲区待命。 其次，保留站会直接把读取的数据缓冲下来，而不像记分牌一样只记录一个寄存器编号，只记录编号的话会造成读后写阻塞，因为一条指令在正式执行前一直在监控着它的源寄存器，源寄存器的值是不能改变的，因此后续指令无法写回，只能阻塞流水，而保留站则贯彻了“数据一旦准备完毕，就立马执行指令”的思想，指令一旦发现有数据可读，就立马读下来，读下来之后，那个源寄存器的写与不写就不关己事了。 记分牌和保留站相同的地方是都记录了Qj和Qk，即一旦需要的数据被算出来，就通过Qj和Qk捕捉广播数据，这样的做法其实就是重命名，即用保留站的编号而不是寄存器编号来标记数据源。 除了保留站数据结构之外，Tomasulo同样要记录寄存器结果状态，记录信息如图6.和记分牌一样，Tomasulo也会记录寄存器将被哪条指令更新，这个信息在指令寻找源数据时被使用。 2.2.2 调度流程MIPS五阶段的流水线的改造ID和EX阶段被以下三个阶段代替 1.流出(Issue) 2.执行(Execute) 3.结果写回(Write result) 流出(Issue)1.从浮点指令队列中取出一条指令 2.如果存在一个空的保留站，就流出这条指令 3.如果操作数在寄存器中，就送到该指令对应的保留站 4.存储器取&#x2F;存指令只要有空闲的缓存就可以流出 5.如果没有空闲的保留站或者缓存，就存在结构相关，指令暂停，直到有空闲的保留站或者缓存 执行(Execute)1.如果缺少一个或者多个操作数，就监听CBD 这个阶段实际是检测和自动维护RAW相关 2.如果两个操作数都就绪，这条指令就可以执行 结果写回(Write result)1.如果结果已经产生，将其写到CBD上 2.通过CDB,把这个结果写到目标寄存器和等待这个结果的所有功能单元的保留站","tags":["指令的动态调度"],"categories":["计算机体系结构"]},{"title":"计算机体系结构-记分牌ScoreBoard","path":"/2023/05/25/计算机体系结构-记分牌ScoreBoard/","content":"1.什么是记分牌首先需要认识到一个事实：顺序执行的处理器有瑕疵 比如说lw指令后面跟着一连串与它无关的指令，但是lw指令发生了 data cache miss 的情况，导致了必须访问主存，所以就很慢，但是它卡在访存阶段几十上百个周期，如果是顺序执行，后面的指令会等他结束在执行，效率太低，如果想要实现“继续执行”，即后面的指令“绕过” lw 指令继续执行，那么就需要处理器支持乱序 1.1 乱序执行顺序执行的效率太慢，如果有一条指令阻塞，那么后面所有的指令都会阻塞，所以设计师开了几条近道，让后面的指令可以绕过前面的指令，从而继续执行。 在乱序情况下，只要一条指令所需要的数据准备好了，那么就执行这条指令，而不用像顺序执行一样既要准备好数据，又要前面的指令把”路“让出来。 1.2 多配置流水传统的五级流水线中，所有的指令都要走完运算通路，计算指令不需要访问存储器，所以完全可以绕开存储器，但正是因为这样的规定，导致前面的lw指令卡在了访存环节中，导致计算指令只能等lw指令把存储器让出来。 所以就有了多配置流水，针对不同的计算指令的不同的要求，为之开辟不同的道路，有这些路指令就可以实现超车。多配置流水的处理器可以实现乱序执行。 1.3 记分牌算法下面是CDC 6600 的结构示意： 可以看到有两个浮点乘法器(FP mult)，一个浮点除法器(FP divide)，一个浮点加法器(FP add)，一个整型单元(Integer unit:用于计算存储地址)，和记分牌(Scoreboard),记分牌是信息存储单元，接下来两张图解释它究竟什么功能。 上图是记分牌存储的信息-功能单元状态，可以得知记分牌掌控着各个功能单元的功能 Busy表明单元是否被使用 Op则表示现在执行的哪一种指令 Fi是目的寄存器 Fj，Fk是源寄存器 Qj，Qk在确定源寄存器中没有准备好的后，表明源寄存器的值要从哪一个单元的目的寄存器中得到。 Rj，Rk标志Fj，Fk是否就绪，是否已经被使用 上图是记分牌存储的信息-寄存器结果状态，专门用于记录哪个寄存器要作为某功能部件的目的寄存器。如图：F4就要作为MULT部件的目的寄存器 2、工作流程解读在用记分牌实现乱序执行的处理器中（这里特指 CDC 6600 处理器了），一条指令分四个阶段执行，分别是发射、读数、执行、写回。本节会逐阶段解读工作过程。 对示意图做一点补充，黄色方框表示流水段寄存器，分别有指令寄存器、部件寄存器（即 MUL_1 这一列）、操作数寄存器（ OPRAND ）、结果寄存器（ RESULT ）。蓝色部分是解码单元和运算单元。红色部分是寄存器堆。绿色部分是记分牌。解码单元和记分牌的交互是指解码单元要“问”记分牌当前指令是否有“ WAW 冒险”和“ Structure 结构冒险”，如果没有，指令就可以顺利渡过当前的阶段，后面的 RAW、WAR 也都是这个意思。 ID段流水线ID段被分为两级 流出-解析指令，检查结构相关 读操作数一直到不存在数据相关时，才读取操作数 如果存在WAR或者WRW相关，记分牌会暂时暂停该指令的执行，知道相关消除后才继续执行 流出(Issue)1.本指令所需要的功能部件有空闲 2.正在执行指令使用的目的寄存器与本指令不同 保证WAW相关 读操作数(Read operands)1.前面已经流出的还在运行的指令不对本指令的源操作数寄存器进行写操作 2.一个正在工作的功能部件已经完成了对这个寄存器的写操作 3.动态解决RAW相关 前面两步完成原来ID段的功能 执行(Execution)1.开始于取到操作数后 2.当结果产生后，修改记分牌 3.FP流水部件会占用多个周期 写结果(Write result)检查WAR相关 出现以下情况时，不允许指令写结果：1.前面的某条指令没有读取操作数 2.其中的某个源操作数寄存器与本指令的目的寄存器相同 记分牌的优缺点记分牌算法是 CDC 公司提出的一个优秀的乱序执行算法，不过记分牌本身还是有一些不小的缺点，所以在 IBM 提出 Tomasulo 算法之后，业界普遍更青睐 Tomasulo 算法。 记分牌算法的优点是实现了指令的乱序执行，解决了乱序执行过程中的数据冒险问题，实现了指令的数据流式运行（即数据一旦准备好就开始运行，这区别于传统五级流水线中控制运行方式），并且实现起来并不复杂。 但是记分牌算法还是会因为 WAR 和 WAW 冒险而产生阻塞，且一旦产生阻塞，后续相同类型的指令就没办法继续发射（在乱序执行过程中，记分牌规定每一条配置路线都只能同时存在一条指令），即图中所列的“ Limited waiting space at functional units ”，如果后续相同类型的指令没法发射，那么更后面的也许可以立马执行的指令也会被阻塞到，这对性能有很大的影响。 而且记分牌算法在指令完成时不是顺序的（即写回的时候不按顺序），不按顺序完成指令会对程序的调试提出挑战。 总结记分牌算法由 CDC 公司在上个世纪六十年代提出，是一个实现方式简单的乱序执行算法，应用多配置流水和记分牌算法，就可以实现一个乱序执行的处理器。但是记分牌又有一些缺点，这些缺点给了 IBM 提出的 Tomasulo 算法后来居上的机会。随着学习的深入，我后面会继续更新 Tomasulo 算法的原理和算法流程。","tags":["指令的动态调度"],"categories":["计算机体系结构"]},{"title":"哥们的第一篇博客","path":"/2023/05/24/哥们的第一篇博客-测试/","content":"我的第一篇博客其实我开始博客的时间已经相当晚了，现在已经是大三的下学期即将画上句号，按理说能学得都已经学完了，现在正是把学到的东西实践的时刻了。可惜我学艺不精，所以决定考研这条路，也就意味着我的专业课知识得从头来过，不过这也没什么好后悔的，正好以这为教训，引以为鉴。 种一棵树最好的时间是十年前，其次是现在。 准备搭建博客的目的也是为此，决定将我学到的东西分享到网上，正好督促我自己的学习进度，并且这种文书工作我也并不讨厌，可以说得上相得益彰了。总之，学习的路很长，漫漫长路从脚下开始。从今天开始我会将一些学习笔记、不那么隐私的生活感悟写进我的博客，如果你看到了，请付之一笑，这些只不过是我年少的妄语，随着时间的推移，身份的改变，我自己肯定也会改变的，再回过头来看说不定也觉得现在的自己年轻幼稚。","tags":["随笔"]},{"title":"Hello World","path":"/2023/05/23/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"404","path":"/404/index.html","content":""},{"title":"关于","path":"/about/index.html","content":""},{"title":"分类","path":"/categories/index.html","content":""},{"title":"notes","path":"/notes/index.html","content":""},{"title":"音乐","path":"/music/index.html","content":""},{"title":"资源","path":"/resources/index.html","content":""},{"title":"reading","path":"/reading/index.html","content":"书籍是人类进步的阶梯"},{"title":"标签","path":"/tags/index.html","content":""},{"title":"wiki","path":"/wiki/index.html","content":""},{"title":"测试","path":"/notes/测试/index.html","content":""},{"title":"站点美化","path":"/notes/站点美化/index.html","content":""},{"title":"这是分页标题","path":"/wiki/阅读/index.html","content":""}]